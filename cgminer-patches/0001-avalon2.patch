diff --git a/A1-board-selector-CCD.c b/A1-board-selector-CCD.c
new file mode 100644
index 0000000..d9c8528
--- /dev/null
+++ b/A1-board-selector-CCD.c
@@ -0,0 +1,119 @@
+/*
+ * board selector support for TCA9535 used in Bitmine's CoinCraft Desk
+ *
+ * Copyright 2014 Zefir Kurtisi <zefir.kurtisi@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 3 of the License, or (at your option)
+ * any later version.  See COPYING for more details.
+ */
+
+
+#include <sys/ioctl.h>
+#include <errno.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <fcntl.h>
+
+#include "miner.h"
+
+#include "A1-board-selector.h"
+
+static struct board_selector ccd_selector;
+
+struct ccd_ctx {
+	struct i2c_ctx U1_tca9535;
+	uint8_t board_mask;
+	uint8_t active_board;
+	pthread_mutex_t lock;
+};
+
+static struct ccd_ctx ccd_ctx = {
+	.U1_tca9535 = { .addr = 0x27, .file = -1 },
+	.board_mask = 0xff,
+	.active_board = 255,
+};
+
+#define UNUSED_BITS 0xe0
+
+static void ccd_unlock(void)
+{
+	mutex_unlock(&ccd_ctx.lock);
+}
+
+static void ccd_exit(void)
+{
+	i2c_slave_close(&ccd_ctx.U1_tca9535);
+}
+
+extern struct board_selector *ccd_board_selector_init(void)
+{
+	mutex_init(&ccd_ctx.lock);
+	struct i2c_ctx *ctx = &ccd_ctx.U1_tca9535;
+	bool retval =	i2c_slave_open(ctx, I2C_BUS) &&
+			i2c_slave_write(ctx, 0x06, 0xe0) &&
+			i2c_slave_write(ctx, 0x07, 0xe0) &&
+			i2c_slave_write(ctx, 0x02, 0x1f) &&
+			i2c_slave_write(ctx, 0x03, 0x00);
+	if (retval)
+		return &ccd_selector;
+	ccd_exit();
+	return NULL;
+}
+
+static bool ccd_select(uint8_t board)
+{
+	if (board >= CCD_MAX_CHAINS)
+		return false;
+
+	mutex_lock(&ccd_ctx.lock);
+	if (ccd_ctx.active_board == board)
+		return true;
+
+	ccd_ctx.active_board = board;
+	ccd_ctx.board_mask = 1 << ccd_ctx.active_board;
+	return i2c_slave_write(&ccd_ctx.U1_tca9535, 0x02, ~ccd_ctx.board_mask);
+}
+
+static bool __ccd_board_selector_reset(uint8_t mask)
+{
+	if (!i2c_slave_write(&ccd_ctx.U1_tca9535, 0x03, mask))
+		return false;
+	cgsleep_ms(RESET_LOW_TIME_MS);
+	if (!i2c_slave_write(&ccd_ctx.U1_tca9535, 0x03, 0x00))
+		return false;
+	cgsleep_ms(RESET_HI_TIME_MS);
+	return true;
+}
+// we assume we are already holding the mutex
+static bool ccd_reset(void)
+{
+	return __ccd_board_selector_reset(ccd_ctx.board_mask);
+}
+
+static bool ccd_reset_all(void)
+{
+	mutex_lock(&ccd_ctx.lock);
+	bool retval = __ccd_board_selector_reset(0xff & ~UNUSED_BITS);
+	mutex_unlock(&ccd_ctx.lock);
+	return retval;
+}
+
+
+static struct board_selector ccd_selector = {
+	.select = ccd_select,
+	.release = ccd_unlock,
+	.exit = ccd_exit,
+	.reset = ccd_reset,
+	.reset_all = ccd_reset_all,
+	.get_temp = dummy_u8,
+};
+
diff --git a/A1-board-selector-CCR.c b/A1-board-selector-CCR.c
new file mode 100644
index 0000000..b60d58e
--- /dev/null
+++ b/A1-board-selector-CCR.c
@@ -0,0 +1,305 @@
+/*
+ * board selector support for TCA9535 used in Bitmine's CoinCraft Desk
+ *
+ * Copyright 2014 Zefir Kurtisi <zefir.kurtisi@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 3 of the License, or (at your option)
+ * any later version.  See COPYING for more details.
+ */
+
+
+#include <sys/ioctl.h>
+#include <errno.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <fcntl.h>
+
+#include "miner.h"
+
+#include "A1-board-selector.h"
+
+static struct board_selector ccr_selector;
+
+
+bool i2c_slave_write(struct i2c_ctx *ctx, uint8_t reg, uint8_t val)
+{
+	union i2c_smbus_data data;
+	data.byte = val;
+
+	struct i2c_smbus_ioctl_data args;
+
+	args.read_write = I2C_SMBUS_WRITE;
+	args.command = reg;
+	args.size = I2C_SMBUS_BYTE_DATA;
+	args.data = &data;
+
+	if (ioctl(ctx->file, I2C_SMBUS, &args) == -1) {
+		applog(LOG_ERR, "Failed to write to fdesc %d: %s",
+		       ctx->file, strerror(errno));
+		return false;
+	}
+	applog(LOG_DEBUG, "W(0x%02x/0x%02x)=0x%02x", ctx->addr, reg, val);
+	return true;
+}
+
+bool i2c_slave_read(struct i2c_ctx *ctx, uint8_t reg, uint8_t *val)
+{
+	union i2c_smbus_data data;
+	struct i2c_smbus_ioctl_data args;
+
+	args.read_write = I2C_SMBUS_READ;
+	args.command = reg;
+	args.size = I2C_SMBUS_BYTE_DATA;
+	args.data = &data;
+
+	if (ioctl(ctx->file, I2C_SMBUS, &args) == -1) {
+		applog(LOG_ERR, "Failed to read from fdesc %d: %s",
+		       ctx->file, strerror(errno));
+		return false;
+	}
+	*val = data.byte;
+	applog(LOG_DEBUG, "R(0x%02x/0x%02x)=0x%02x", ctx->addr, reg, *val);
+	return true;
+}
+
+bool i2c_slave_open(struct i2c_ctx *ctx, char *i2c_bus)
+{
+	ctx->file = open(i2c_bus, O_RDWR);
+	if (ctx->file < 0) {
+		applog(LOG_INFO, "Failed to open i2c-1: %s", strerror(errno));
+		return false;
+	}
+
+	if (ioctl(ctx->file, I2C_SLAVE, ctx->addr) < 0) {
+		close(ctx->file);
+		return false;
+	}
+	return true;
+}
+
+void i2c_slave_close(struct i2c_ctx *ctx)
+{
+	if (ctx->file == -1)
+		return;
+	close(ctx->file);
+	ctx->file = -1;
+}
+
+
+struct ccr_ctx {
+	struct i2c_ctx U1_tca9548;
+	struct i2c_ctx U2_tca9535;
+	struct i2c_ctx U3_tca9535;
+	struct i2c_ctx U4_tca9535;
+	uint16_t chain_mask;
+	uint8_t active_chain;
+	pthread_mutex_t lock;
+	uint8_t boards_available;
+};
+
+static struct ccr_ctx ccr_ctx = {
+	.U1_tca9548 = { .addr = 0x70, .file = -1, },
+	.U2_tca9535 = { .addr = 0x20, .file = -1, },
+	.U3_tca9535 = { .addr = 0x23, .file = -1, },
+	.U4_tca9535 = { .addr = 0x22, .file = -1, },
+	.chain_mask = 0xffff,
+	.active_chain = 255,
+	.boards_available = 0x00,
+};
+
+struct chain_mapping {
+	uint8_t chain_id;
+	uint8_t U1;
+	uint8_t U2p0;
+	uint8_t U2p1;
+	uint8_t U3p0;
+	uint8_t U3p1;
+};
+
+static const struct chain_mapping chain_mapping[CCR_MAX_CHAINS] = {
+	{  0, 0x01, 0x01, 0x80, 0x01, 0x00, },
+	{  1, 0x01, 0x01, 0x80, 0x00, 0x80, },
+	{  2, 0x02, 0x02, 0x40, 0x02, 0x00, },
+	{  3, 0x02, 0x02, 0x40, 0x00, 0x40, },
+	{  4, 0x04, 0x04, 0x20, 0x04, 0x00, },
+	{  5, 0x04, 0x04, 0x20, 0x00, 0x20, },
+	{  6, 0x08, 0x08, 0x10, 0x08, 0x00, },
+	{  7, 0x08, 0x08, 0x10, 0x00, 0x10, },
+	{  8, 0x10, 0x10, 0x08, 0x10, 0x00, },
+	{  9, 0x10, 0x10, 0x08, 0x00, 0x08, },
+	{ 10, 0x20, 0x20, 0x04, 0x20, 0x00, },
+	{ 11, 0x20, 0x20, 0x04, 0x00, 0x04, },
+	{ 12, 0x40, 0x40, 0x02, 0x40, 0x00, },
+	{ 13, 0x40, 0x40, 0x02, 0x00, 0x02, },
+	{ 14, 0x80, 0x80, 0x01, 0x80, 0x00, },
+	{ 15, 0x80, 0x80, 0x01, 0x00, 0x01, },
+};
+
+static void ccr_unlock(void)
+{
+	mutex_unlock(&ccr_ctx.lock);
+}
+
+static void ccr_exit(void)
+{
+	i2c_slave_close(&ccr_ctx.U1_tca9548);
+	i2c_slave_close(&ccr_ctx.U2_tca9535);
+	i2c_slave_close(&ccr_ctx.U3_tca9535);
+	i2c_slave_close(&ccr_ctx.U4_tca9535);
+}
+
+static bool ccr_power_on_one_board(uint8_t chain)
+{
+	const struct chain_mapping *cm = &chain_mapping[chain];
+	if (chain & 1)
+		return false;
+	uint8_t new_power_mask = ccr_ctx.boards_available | cm->U2p0;
+	if (!i2c_slave_write(&ccr_ctx.U2_tca9535, 0x03, new_power_mask))
+		return false;
+	int i;
+	for (i = 0; i < 8; i ++) {
+		uint8_t val;
+		if (!i2c_slave_read(&ccr_ctx.U2_tca9535, 0x00, &val))
+			return false;
+		if (val & cm->U2p1) {
+			applog(LOG_INFO, "Power OK for chain %d after %d",
+			       chain, i);
+			ccr_ctx.boards_available = new_power_mask;
+			return true;
+		}
+		cgsleep_ms(10);
+	}
+	applog(LOG_INFO, "Power NOK for chain %d", chain);
+	return false;
+}
+static int ccr_power_on_boards(void)
+{
+	int i;
+	int boards = 0;
+	for (i = 0; i < CCR_MAX_CHAINS / 2; i++) {
+		if (ccr_power_on_one_board(i * 2))
+			boards++;
+	}
+	return boards;
+}
+
+extern struct board_selector *ccr_board_selector_init(void)
+{
+	mutex_init(&ccr_ctx.lock);
+	applog(LOG_INFO, "ccr_board_selector_init()");
+
+			/* detect all i2c slaves */
+	bool res =	i2c_slave_open(&ccr_ctx.U1_tca9548, I2C_BUS) &&
+			i2c_slave_open(&ccr_ctx.U2_tca9535, I2C_BUS) &&
+			i2c_slave_open(&ccr_ctx.U3_tca9535, I2C_BUS) &&
+			i2c_slave_open(&ccr_ctx.U4_tca9535, I2C_BUS) &&
+			/* init I2C multiplexer */
+			i2c_slave_write(&ccr_ctx.U1_tca9548, 0x00, 0x00) &&
+			/* init power selector */
+			i2c_slave_write(&ccr_ctx.U2_tca9535, 0x06, 0xff) &&
+			i2c_slave_write(&ccr_ctx.U2_tca9535, 0x07, 0x00) &&
+			i2c_slave_write(&ccr_ctx.U2_tca9535, 0x03, 0x00) &&
+			/* init reset selector */
+			i2c_slave_write(&ccr_ctx.U3_tca9535, 0x06, 0x00) &&
+			i2c_slave_write(&ccr_ctx.U3_tca9535, 0x07, 0x00) &&
+			i2c_slave_write(&ccr_ctx.U3_tca9535, 0x02, 0x00) &&
+			i2c_slave_write(&ccr_ctx.U3_tca9535, 0x03, 0x00) &&
+			/* init chain selector */
+			i2c_slave_write(&ccr_ctx.U4_tca9535, 0x06, 0x00) &&
+			i2c_slave_write(&ccr_ctx.U4_tca9535, 0x07, 0x00) &&
+			i2c_slave_write(&ccr_ctx.U4_tca9535, 0x02, 0x00) &&
+			i2c_slave_write(&ccr_ctx.U4_tca9535, 0x03, 0x00);
+
+	if (!res)
+		goto fail;
+
+	if (ccr_power_on_boards() == 0)
+		goto fail;
+
+	return &ccr_selector;
+
+fail:
+	ccr_exit();
+	return NULL;
+}
+
+static bool ccr_select(uint8_t chain)
+{
+	if (chain >= CCR_MAX_CHAINS)
+		return false;
+
+	mutex_lock(&ccr_ctx.lock);
+	if (ccr_ctx.active_chain == chain)
+		return true;
+
+	ccr_ctx.active_chain = chain;
+	const struct chain_mapping *cm = &chain_mapping[chain];
+	if (!i2c_slave_write(&ccr_ctx.U4_tca9535, 0x02, cm->U3p0) ||
+	    !i2c_slave_write(&ccr_ctx.U4_tca9535, 0x03, cm->U3p1) ||
+	    !i2c_slave_write(&ccr_ctx.U1_tca9548, cm->U1, cm->U1))
+		return false;
+
+	applog(LOG_DEBUG, "selected chain %d", chain);
+	return true;
+}
+
+static bool __ccr_board_selector_reset(uint8_t p0, uint8_t p1)
+{
+	if (!i2c_slave_write(&ccr_ctx.U3_tca9535, 0x02, p0) ||
+	    !i2c_slave_write(&ccr_ctx.U3_tca9535, 0x03, p1))
+		return false;
+	cgsleep_ms(RESET_LOW_TIME_MS);
+	if (!i2c_slave_write(&ccr_ctx.U3_tca9535, 0x02, 0x00) ||
+	    !i2c_slave_write(&ccr_ctx.U3_tca9535, 0x03, 0x00))
+		return false;
+	cgsleep_ms(RESET_HI_TIME_MS);
+	return true;
+}
+// we assume we are already holding the mutex
+static bool ccr_reset(void)
+{
+	const struct chain_mapping *cm = &chain_mapping[ccr_ctx.active_chain];
+	bool retval = __ccr_board_selector_reset(cm->U3p0, cm->U3p1);
+	return retval;
+}
+
+static bool ccr_reset_all(void)
+{
+	mutex_lock(&ccr_ctx.lock);
+	bool retval = __ccr_board_selector_reset(0xff, 0xff);
+	mutex_unlock(&ccr_ctx.lock);
+	return retval;
+}
+
+static uint8_t ccr_get_temp(void)
+{
+	if (ccr_ctx.active_chain & 1)
+		return 0;
+
+	uint8_t retval = 0;
+	static struct i2c_ctx U7 = { .addr = 0x4c, .file = -1 };
+	if (i2c_slave_open(&U7, I2C_BUS)) {
+		i2c_slave_read(&U7, 0, &retval);
+		i2c_slave_close(&U7);
+	}
+	return retval;
+}
+
+static struct board_selector ccr_selector = {
+	.select = ccr_select,
+	.release = ccr_unlock,
+	.exit = ccr_exit,
+	.reset = ccr_reset,
+	.reset_all = ccr_reset_all,
+	.get_temp = ccr_get_temp,
+};
+
diff --git a/A1-board-selector.h b/A1-board-selector.h
new file mode 100644
index 0000000..9102f70
--- /dev/null
+++ b/A1-board-selector.h
@@ -0,0 +1,54 @@
+#ifndef A1_BOARD_SELECTOR_H
+#define A1_BOARD_SELECTOR_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#define RESET_LOW_TIME_MS 200
+#define RESET_HI_TIME_MS  100
+
+struct board_selector {
+	bool (*select)(uint8_t board);
+	void (*release)(void);
+	void (*exit)(void);
+	bool (*reset)(void);
+	bool (*reset_all)(void);
+	uint8_t (*get_temp)(void);
+};
+
+static bool dummy_select(uint8_t b) { (void)b; return true; }
+static void dummy_void(void) { };
+static bool dummy_bool(void) { return true; }
+static uint8_t dummy_u8(void) { return 0; }
+
+static const struct board_selector dummy_board_selector = {
+	.select = dummy_select,
+	.release = dummy_void,
+	.exit = dummy_void,
+	.reset = dummy_bool,
+	.reset_all = dummy_bool,
+	.get_temp = dummy_u8,
+};
+
+/* CoinCraft Desk and Rig board selector constructors */
+#define CCD_MAX_CHAINS	5
+#define CCR_MAX_CHAINS	16
+extern struct board_selector *ccd_board_selector_init(void);
+extern struct board_selector *ccr_board_selector_init(void);
+
+
+/* common i2c context */
+struct i2c_ctx {
+	uint8_t addr;
+	int file;
+};
+
+/* the default I2C bus on RPi */
+#define I2C_BUS		"/dev/i2c-1"
+
+extern bool i2c_slave_write(struct i2c_ctx *ctx, uint8_t reg, uint8_t val);
+extern bool i2c_slave_read(struct i2c_ctx *ctx, uint8_t reg, uint8_t *val);
+extern bool i2c_slave_open(struct i2c_ctx *ctx, char *i2c_bus);
+extern void i2c_slave_close(struct i2c_ctx *ctx);
+
+#endif /* A1_BOARD_SELECTOR_H */
diff --git a/A1-common.h b/A1-common.h
new file mode 100644
index 0000000..27fd60d
--- /dev/null
+++ b/A1-common.h
@@ -0,0 +1,89 @@
+#ifndef A1_COMMON_H
+#define A1_COMMON_H
+
+#include <stddef.h>
+#include <stdbool.h>
+#include <stdint.h>
+
+/********** work queue */
+struct work_ent {
+	struct work *work;
+	struct list_head head;
+};
+
+struct work_queue {
+	int num_elems;
+	struct list_head head;
+};
+
+/********** chip and chain context structures */
+/* the WRITE_JOB command is the largest (2 bytes command, 56 bytes payload) */
+#define WRITE_JOB_LENGTH	58
+#define MAX_CHAIN_LENGTH	64
+/*
+ * For commands to traverse the chain, we need to issue dummy writes to
+ * keep SPI clock running. To reach the last chip in the chain, we need to
+ * write the command, followed by chain-length words to pass it through the
+ * chain and another chain-length words to get the ACK back to host
+ */
+#define MAX_CMD_LENGTH		(WRITE_JOB_LENGTH + MAX_CHAIN_LENGTH * 2 * 2)
+
+struct A1_chip {
+	int num_cores;
+	int last_queued_id;
+	struct work *work[4];
+	/* stats */
+	int hw_errors;
+	int stales;
+	int nonces_found;
+	int nonce_ranges_done;
+
+	/* systime in ms when chip was disabled */
+	int cooldown_begin;
+	/* number of consecutive failures to access the chip */
+	int fail_count;
+	/* mark chip disabled, do not try to re-enable it */
+	bool disabled;
+};
+
+struct A1_chain {
+	int chain_id;
+	struct cgpu_info *cgpu;
+	struct mcp4x *trimpot;
+	int num_chips;
+	int num_cores;
+	int num_active_chips;
+	int chain_skew;
+	uint8_t spi_tx[MAX_CMD_LENGTH];
+	uint8_t spi_rx[MAX_CMD_LENGTH];
+	struct spi_ctx *spi_ctx;
+	struct A1_chip *chips;
+	pthread_mutex_t lock;
+
+	struct work_queue active_wq;
+
+	uint8_t temp;
+	int last_temp_time;
+};
+
+#define MAX_CHAINS_PER_BOARD	2
+struct A1_board {
+	int board_id;
+	int num_chains;
+	struct A1_chain *chain[MAX_CHAINS_PER_BOARD];
+};
+
+/********** config paramters */
+struct A1_config_options {
+	int ref_clk_khz;
+	int sys_clk_khz;
+	int spi_clk_khz;
+	/* limit chip chain to this number of chips (testing only) */
+	int override_chip_num;
+	int wiper;
+};
+
+/* global configuration instance */
+extern struct A1_config_options A1_config_options;
+
+#endif /* A1_COMMON_H */
diff --git a/A1-desk-board-selector-tca9535.c b/A1-desk-board-selector-tca9535.c
deleted file mode 100644
index 5a451f6..0000000
--- a/A1-desk-board-selector-tca9535.c
+++ /dev/null
@@ -1,147 +0,0 @@
-#include <sys/ioctl.h>
-#include <errno.h>
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <linux/i2c.h>
-#include <linux/i2c-dev.h>
-
-#include <stdint.h>
-#include <stdbool.h>
-#include <fcntl.h>
-
-#include "miner.h"
-
-struct tca9535_ctx {
-	uint8_t addr;
-	uint8_t board_mask;
-	int file;
-	uint8_t active_board;
-	pthread_mutex_t lock;
-};
-
-static struct tca9535_ctx board_ctx = {
-	.addr = 0x27,
-	.board_mask = 0xff,
-	.file = -1,
-	.active_board = 255,
-};
-
-
-#define UNUSED_BITS 0xe0
-#define SLEEP_US_AFTER_CS 200
-#define RESET_LOW_TIME_MS 200
-#define RESET_HI_TIME_MS  100
-
-static bool tca9535_write(int fdesc, uint8_t p0, uint8_t p1)
-{
-	union i2c_smbus_data data;
-	data.byte = p1;
-
-	struct i2c_smbus_ioctl_data args;
-	__s32 err;
-
-	args.read_write = I2C_SMBUS_WRITE;
-	args.command = p0;
-	args.size = I2C_SMBUS_BYTE_DATA;
-	args.data = &data;
-
-	err = ioctl(fdesc, I2C_SMBUS, &args);
-	if (err == -1) {
-		applog(LOG_ERR, "Failed to write to fdesc %d: %s\n",
-		       fdesc, strerror(errno));
-		err = -errno;
-	} else {
-		applog(LOG_DEBUG, "written: 0x%02x, 0x%02x", p0, p1);
-		cgsleep_us(SLEEP_US_AFTER_CS);
-	}
-	return err == 0;
-}
-
-void lock_board_selector(void)
-{
-//	applog(LOG_WARNING, "lock_board_selector()");
-	mutex_lock(&board_ctx.lock);
-}
-
-void unlock_board_selector(void)
-{
-//	applog(LOG_WARNING, "unlock_board_selector()");
-	mutex_unlock(&board_ctx.lock);
-}
-
-bool a1_board_selector_init(void)
-{
-	mutex_init(&board_ctx.lock);
-	applog(LOG_WARNING, "a1_board_selector_init()");
-
-	board_ctx.file = open("/dev/i2c-1", O_RDWR);
-	if (board_ctx.file < 0) {
-		fprintf(stderr,
-			"Error: Could not open i2c-1.%d: %s\n",
-			board_ctx.addr, strerror(errno));
-		return false;
-	}
-
-	if (ioctl(board_ctx.file, I2C_SLAVE, board_ctx.addr) < 0) {
-		fprintf(stderr,
-			"Error: Could not set address to 0x%02x: %s\n",
-			board_ctx.addr, strerror(errno));
-		return false;
-	}
-	bool retval =	tca9535_write(board_ctx.file, 0x06, 0xe0) &&
-			tca9535_write(board_ctx.file, 0x07, 0xe0) &&
-			tca9535_write(board_ctx.file, 0x02, 0x1f) &&
-			tca9535_write(board_ctx.file, 0x03, 0x00);
-	return retval;
-}
-
-void a1_board_selector_exit(void)
-{
-	close(board_ctx.file);
-	board_ctx.file = -1;
-}
-
-bool a1_board_selector_select_board(uint8_t board)
-{
-	if (board > 7)
-		return false;
-
-//	applog(LOG_WARNING, "board_selector_select_board(%d)", board);
-	lock_board_selector();
-	if (board_ctx.active_board == board)
-		return true;
-
-	board_ctx.active_board = board;
-	board_ctx.board_mask = 1 << board_ctx.active_board;
-	return tca9535_write(board_ctx.file, 0x02, ~board_ctx.board_mask);
-}
-
-static bool __board_selector_reset(void)
-{
-	if (!tca9535_write(board_ctx.file, 0x03, board_ctx.board_mask))
-		return false;
-	cgsleep_ms(RESET_LOW_TIME_MS);
-	if (!tca9535_write(board_ctx.file, 0x03, 0x00))
-		return false;
-	cgsleep_ms(RESET_HI_TIME_MS);
-	return true;
-}
-// we assume we are already holding the mutex
-bool a1_board_selector_reset_board(void)
-{
-	bool retval = __board_selector_reset();
-	return retval;
-}
-
-bool a1_board_selector_reset_all_boards(void)
-{
-	lock_board_selector();
-	board_ctx.board_mask = 0xff & ~UNUSED_BITS;
-	bool retval = __board_selector_reset();
-	unlock_board_selector();
-	return retval;
-}
-
-/////////////////////////////////////////////////////////////////////////////
diff --git a/A1-trimpot-mcp4x.c b/A1-trimpot-mcp4x.c
new file mode 100644
index 0000000..a9244fd
--- /dev/null
+++ b/A1-trimpot-mcp4x.c
@@ -0,0 +1,116 @@
+/*
+ * support for MCP46x digital trimpot used in Bitmine's products
+ *
+ * Copyright 2014 Zefir Kurtisi <zefir.kurtisi@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 3 of the License, or (at your option)
+ * any later version.  See COPYING for more details.
+ */
+
+
+#include <assert.h>
+#include <errno.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <sys/ioctl.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <fcntl.h>
+
+#include "miner.h"
+
+#include "A1-trimpot-mcp4x.h"
+
+
+static bool mcp4x_check_status(int file)
+{
+	union i2c_smbus_data data;
+	struct i2c_smbus_ioctl_data args;
+
+	args.read_write = I2C_SMBUS_READ;
+	args.command = ((5 & 0x0f) << 4) | 0x0c;
+	args.size = I2C_SMBUS_WORD_DATA;
+	args.data = &data;
+
+	return ioctl(file, I2C_SMBUS, &args) >= 0;
+}
+
+static uint16_t mcp4x_get_wiper(struct mcp4x *me, uint8_t id)
+{
+	assert(id < 2);
+	union i2c_smbus_data data;
+	struct i2c_smbus_ioctl_data args;
+
+	args.read_write = I2C_SMBUS_READ;
+	args.command = ((id & 0x0f) << 4) | 0x0c;
+	args.size = I2C_SMBUS_WORD_DATA;
+	args.data = &data;
+
+	if (ioctl(me->file, I2C_SMBUS, &args) < 0) {
+		applog(LOG_ERR, "Failed to read id %d: %s\n", id,
+		       strerror(errno));
+		return 0xffff;
+	}
+	return htobe16(data.word & 0xffff);
+}
+
+static bool mcp4x_set_wiper(struct mcp4x *me, uint8_t id, uint16_t w)
+{
+	assert(id < 2);
+	union i2c_smbus_data data;
+	data.word = w;
+
+	struct i2c_smbus_ioctl_data args;
+
+	args.read_write = I2C_SMBUS_WRITE;
+	args.command = (id & 0x0f) << 4;
+	args.size = I2C_SMBUS_WORD_DATA;
+	args.data = &data;
+
+	if (ioctl(me->file, I2C_SMBUS, &args) < 0) {
+		applog(LOG_ERR, "Failed to read id %d: %s\n", id,
+		       strerror(errno));
+		return false;
+	}
+	return me->get_wiper(me, id) == w;
+}
+
+void mcp4x_exit(struct mcp4x *me)
+{
+	close(me->file);
+	free(me);
+}
+
+struct mcp4x *mcp4x_init(uint8_t addr)
+{
+	struct mcp4x *me;
+	int file = open("/dev/i2c-1", O_RDWR);
+	if (file < 0) {
+		applog(LOG_INFO, "Failed to open i2c-1: %s\n", strerror(errno));
+		return NULL;
+	}
+
+	if (ioctl(file, I2C_SLAVE, addr) < 0)
+		return NULL;
+
+	if (!mcp4x_check_status(file))
+		return NULL;
+
+	me = malloc(sizeof(*me));
+	assert(me != NULL);
+
+	me->addr = addr;
+	me->file = file;
+	me->exit = mcp4x_exit;
+	me->get_wiper = mcp4x_get_wiper;
+	me->set_wiper = mcp4x_set_wiper;
+	return me;
+}
+
diff --git a/A1-trimpot-mcp4x.h b/A1-trimpot-mcp4x.h
new file mode 100644
index 0000000..b7ff600
--- /dev/null
+++ b/A1-trimpot-mcp4x.h
@@ -0,0 +1,19 @@
+#ifndef TRIMPOT_MPC4X_H
+#define TRIMPOT_MPC4X_H
+
+#include <stdint.h>
+#include <stdbool.h>
+
+
+struct mcp4x {
+	uint16_t (*get_wiper)(struct mcp4x *me, uint8_t id);
+	bool (*set_wiper)(struct mcp4x *me, uint8_t id, uint16_t w);
+	void (*exit)(struct mcp4x *me);
+	uint8_t addr;
+	int file;
+};
+
+/* constructor */
+extern struct mcp4x *mcp4x_init(uint8_t addr);
+
+#endif /* TRIMPOT_MPC4X_H */
diff --git a/API-README b/API-README
index a10017c..076785c 100644
--- a/API-README
+++ b/API-README
@@ -136,7 +136,7 @@ If you request a command that can't be used due to requiring parameters,
 a command that isn't a report, or an invalid command, you'll get an 'E' STATUS
 for that one but it will still attempt to process all other commands supplied
 
-Blank/missing commands are ignore e.g. +devs++
+Blank/missing commands are ignored e.g. +devs++
 will just show 'devs' using the new layout
 
 For API version 1.10 and later:
diff --git a/ASIC-README b/ASIC-README
index 6e82783..e68837c 100644
--- a/ASIC-README
+++ b/ASIC-README
@@ -7,6 +7,7 @@ Currently supported devices include:
 - BF1 (bitfury) USB (red and blue)
 - KnCminer Mercury, Saturn and Jupiter
 - BlackArrow Bitfury
+- BlackArrow Minion
 - Bi*fury USB
 - Onestring miner USB
 - Hexfury USB
@@ -55,6 +56,14 @@ The current BlackArrow Bitfury devices are similar to the Bitfury GPIO mining
 boards, with both V1 and V2 controllers, and come up as BaB.
 
 
+BlackArrow Minion devices
+
+BlackArrow Minion devices need the --enable-minion option when compiling
+cgminer.
+
+BlackArrow Minion devices are SPI/GPIO mining devices and come up as MBA
+
+
 BITFURY devices
 
 Bitfury devices need the --enable-bitfury option when compiling cgminer.
@@ -225,6 +234,7 @@ ASIC SPECIFIC COMMANDS
 --hfa-temp-overheat <arg> Set the hashfast overheat throttling temperature (default: 95)
 --hfa-temp-target <arg> Set the hashfast target temperature (0 to disable) (default: 88)
 --klondike-options <arg> Set klondike options clock:temptarget
+--minion-freq <arg> Set minion chip frequencies in MHz, single value or comma list, range 100-1400 (default: 1000)
 --nfu-bits <arg>    Set nanofury bits for overclocking, range 32-63 (default: 50)
 
 
diff --git a/Makefile.am b/Makefile.am
index 573b8d5..184e599 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -14,7 +14,6 @@ EXTRA_DIST	= example.conf linux-usb-cgminer \
 		  API.class API.java api-example.c windows-build.txt \
 		  bitstreams/README API-README FPGA-README \
 		  bitforce-firmware-flash.c hexdump.c ASIC-README \
-		  A1-desk-board-selector.c A1-desk-board-selector-tca9535.c \
 		  01-cgminer.rules
 
 SUBDIRS		= lib compat ccan
@@ -86,6 +85,10 @@ endif
 if HAS_BITMINE_A1
 cgminer_SOURCES += driver-SPI-bitmine-A1.c
 cgminer_SOURCES += spi-context.c spi-context.h
+cgminer_SOURCES += A1-common.h
+cgminer_SOURCES += A1-board-selector.h
+cgminer_SOURCES += A1-board-selector-CCD.c A1-board-selector-CCR.c
+cgminer_SOURCES += A1-trimpot-mcp4x.h A1-trimpot-mcp4x.c
 endif
 
 if HAS_DRILLBIT
diff --git a/NEWS b/NEWS
index eec6a3d..43b63e2 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,45 @@
+Version 4.3.3 - 3rd May 2014
+
+- Fix typo
+- Work should be freed when aged, fixing a massive memory leak for bxf devices
+- miner.php fix single rig summary/config field formatting
+- miner.php fix single rig total formatting
+
+
+Version 4.3.2 - 2nd May 2014
+
+- Fix accounting bug with nrolltime drivers
+
+
+Version 4.3.1 - 2nd May 2014
+
+- upgrade some int to int64_t to avoid overflows in reporting
+- Make reconnection messages more explanatory
+- Stratum client.reconnect require matching URL
+- Fix memory leak in submit_noffset_nonce
+- Clean up any work that may not have been used in the work scheduler
+- Avoid unnecessary deref now that it's done within discard_work
+- Clean work pointers after one way usage functions
+- Avoid unnecessary total_work_inc in generating local work
+- Cosmetic fixes
+- Fix idle bug, when redirected client can't auth
+- Rename spond temp rate to asics total rate
+- Build fixes
+- Set the unique id only for usb devices with serial strings longer than 4 chars
+long
+- Use usb serial strings as unique id if devices have them
+- Discretely identify the onestring miners as OSM
+- Add bxf debugging option and osm led modes
+- A1: modularize board selector / add initial CCR support
+- A1: cleanup tca9535 logging
+- A1: fix and extend PLL parameters
+- A1: clean up compile warnings
+- A1: use real level in hexdump
+- Add identification for onestring miner variants
+- Avalon2: Parser the power good signal
+- driver-avalon2: this functions used on detect, which don't have thr setup yet
+
+
 Version 4.3.0 - 18th April 2014
 
 - Put sleep in spond hash instead of queue full function
diff --git a/README b/README
index 7cd8478..c3eb8d6 100644
--- a/README
+++ b/README
@@ -136,6 +136,7 @@ CGMiner specific configuration options:
                           support
   --without-curses        Compile support for curses TUI (default enabled)
   --with-system-libusb    Compile against dynamic system libusb (default use
+                          included static libusb)
 
 Basic *nix build instructions:
 	To actually build:
@@ -217,6 +218,7 @@ Options for both config file and command line:
 --load-balance      Change multipool strategy from failover to quota based balance
 --log|-l <arg>      Interval in seconds between log output (default: 5)
 --lowmem            Minimise caching of shares for low memory applications
+--minion-freq <arg> Set minion chip frequencies in MHz, single value or comma list, range 100-1400 (default: 1000)
 --monitor|-m <arg>  Use custom pipe cmd for output messages
 --nfu-bits <arg>    Set nanofury bits for overclocking, range 32-63 (default: 50)
 --net-delay         Impose small delays in networking to not overload slow routers
diff --git a/api-example.c b/api-example.c
index 26d5a0e..7cabcac 100644
--- a/api-example.c
+++ b/api-example.c
@@ -1,5 +1,6 @@
 /*
  * Copyright 2011 Kano
+ * Copyright 2014 Mikeqin
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
@@ -13,6 +14,7 @@
 
 #include "config.h"
 
+#include <assert.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -36,7 +38,7 @@
 	#define INVSOCK -1
 	#define CLOSESOCKET close
 
-	#define SOCKETINIT {}
+	#define SOCKETINIT do{}while(0)
 
 	#define SOCKERRMSG strerror(errno)
 #endif
@@ -110,7 +112,6 @@
 
 	static char *WSAErrorMsg()
 	{
-		char *msg;
 		int i;
 		int id = WSAGetLastError();
 
@@ -128,17 +129,22 @@
 
 	static WSADATA WSA_Data;
 
-	#define SOCKETINIT	int wsa; \
-				if (wsa = WSAStartup(0x0202, &WSA_Data)) { \
-					printf("Socket startup failed: %d\n", wsa); \
-					return 1; \
-				}
+	#define SOCKETINIT	do {  \
+				    int wsa; \
+				    if (wsa = WSAStartup(0x0202, &WSA_Data)) { \
+					    printf("Socket startup failed: %d\n", wsa); \
+					    return 1; \
+					}  \
+				} while (0)
 
 	#ifndef SHUT_RDWR
 	#define SHUT_RDWR SD_BOTH
 	#endif
 #endif
 
+#undef RECVSIZE
+#define RECVSIZE 65500
+
 static const char SEPARATOR = '|';
 static const char COMMA = ',';
 static const char EQ = '=';
@@ -189,16 +195,22 @@ void display(char *buf)
 
 int callapi(char *command, char *host, short int port)
 {
-	char buf[RECVSIZE+1];
+	size_t bufsz = RECVSIZE;
+	char *buf = malloc(bufsz + 1);
 	struct hostent *ip;
 	struct sockaddr_in serv;
 	SOCKETTYPE sock;
 	int ret = 0;
 	int n, p;
 
+	assert(buf);
 	SOCKETINIT;
 
 	ip = gethostbyname(host);
+	if (!ip) {
+		printf("Failed to resolve host %s\n", host);
+		return 1;
+	}
 
 	sock = socket(AF_INET, SOCK_STREAM, 0);
 	if (sock == INVSOCK) {
@@ -224,8 +236,14 @@ int callapi(char *command, char *host, short int port)
 	else {
 		p = 0;
 		buf[0] = '\0';
-		while (p < RECVSIZE) {
-			n = recv(sock, &buf[p], RECVSIZE - p , 0);
+		while (1) {
+			if (bufsz < RECVSIZE + p) {
+				bufsz *= 2;
+				buf = realloc(buf, bufsz);
+				assert(buf);
+			}
+			
+			n = recv(sock, &buf[p], RECVSIZE, 0);
 
 			if (SOCKETFAIL(n)) {
 				printf("Recv failed: %s\n", SOCKERRMSG);
@@ -240,14 +258,18 @@ int callapi(char *command, char *host, short int port)
 			buf[p] = '\0';
 		}
 
-		if (ONLY)
-			printf("%s\n", buf);
-		else {
+		if (!ONLY)
 			printf("Reply was '%s'\n", buf);
+		else
+			printf("%s\n", buf);
+
+		if (!ONLY)
 			display(buf);
-		}
 	}
 
+	if (buf)
+	    free(buf);
+
 	CLOSESOCKET(sock);
 
 	return ret;
@@ -281,7 +303,7 @@ int main(int argc, char *argv[])
 		if (strcmp(argv[1], "-?") == 0
 		||  strcmp(argv[1], "-h") == 0
 		||  strcmp(argv[1], "--help") == 0) {
-			fprintf(stderr, "usAge: %s [command [ip/host [port]]]\n", argv[0]);
+			fprintf(stderr, "Usage: %s [command [ip/host [port]]]\n", argv[0]);
 			return 1;
 		}
 
diff --git a/api.c b/api.c
index ef63e95..eebd2a0 100644
--- a/api.c
+++ b/api.c
@@ -916,6 +916,10 @@ static struct api_data *api_add_data_full(struct api_data *root, char *name, enu
 				api_data->data = (void *)malloc(sizeof(uint64_t));
 				*((uint64_t *)(api_data->data)) = *((uint64_t *)data);
 				break;
+			case API_INT64:
+				api_data->data = (void *)malloc(sizeof(int64_t));
+				*((int64_t *)(api_data->data)) = *((int64_t *)data);
+				break;
 			case API_DOUBLE:
 			case API_ELAPSED:
 			case API_MHS:
@@ -1012,6 +1016,11 @@ struct api_data *api_add_uint64(struct api_data *root, char *name, uint64_t *dat
 	return api_add_data_full(root, name, API_UINT64, (void *)data, copy_data);
 }
 
+struct api_data *api_add_int64(struct api_data *root, char *name, int64_t *data, bool copy_data)
+{
+	return api_add_data_full(root, name, API_INT64, (void *)data, copy_data);
+}
+
 struct api_data *api_add_double(struct api_data *root, char *name, double *data, bool copy_data)
 {
 	return api_add_data_full(root, name, API_DOUBLE, (void *)data, copy_data);
@@ -1205,6 +1214,9 @@ static struct api_data *print_data(struct io_data *io_data, struct api_data *roo
 			case API_UINT64:
 				snprintf(buf, sizeof(buf), "%"PRIu64, *((uint64_t *)(root->data)));
 				break;
+			case API_INT64:
+				snprintf(buf, sizeof(buf), "%"PRId64, *((int64_t *)(root->data)));
+				break;
 			case API_TIME:
 				snprintf(buf, sizeof(buf), "%lu", *((unsigned long *)(root->data)));
 				break;
@@ -2019,7 +2031,7 @@ static void ascstatus(struct io_data *io_data, int asc, bool isjson, bool precom
 		root = api_add_int(root, "Last Share Pool", &last_share_pool, false);
 		root = api_add_time(root, "Last Share Time", &(cgpu->last_share_pool_time), false);
 		root = api_add_mhtotal(root, "Total MH", &(cgpu->total_mhashes), false);
-		root = api_add_int(root, "Diff1 Work", &(cgpu->diff1), false);
+		root = api_add_int64(root, "Diff1 Work", &(cgpu->diff1), false);
 		root = api_add_diff(root, "Difficulty Accepted", &(cgpu->diff_accepted), false);
 		root = api_add_diff(root, "Difficulty Rejected", &(cgpu->diff_rejected), false);
 		root = api_add_diff(root, "Last Share Difficulty", &(cgpu->last_share_diff), false);
@@ -2107,7 +2119,7 @@ static void pgastatus(struct io_data *io_data, int pga, bool isjson, bool precom
 		root = api_add_time(root, "Last Share Time", &(cgpu->last_share_pool_time), false);
 		root = api_add_mhtotal(root, "Total MH", &(cgpu->total_mhashes), false);
 		root = api_add_freq(root, "Frequency", &frequency, false);
-		root = api_add_int(root, "Diff1 Work", &(cgpu->diff1), false);
+		root = api_add_int64(root, "Diff1 Work", &(cgpu->diff1), false);
 		root = api_add_diff(root, "Difficulty Accepted", &(cgpu->diff_accepted), false);
 		root = api_add_diff(root, "Difficulty Rejected", &(cgpu->diff_rejected), false);
 		root = api_add_diff(root, "Last Share Difficulty", &(cgpu->last_share_diff), false);
@@ -2178,14 +2190,16 @@ static void devstatus(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __ma
 		io_close(io_data);
 }
 
-static void edevstatus(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)
+static void edevstatus(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)
 {
 	bool io_open = false;
 	int devcount = 0;
 	int numasc = 0;
 	int numpga = 0;
 	int i;
+#ifdef USE_USBUTILS
 	time_t howoldsec = 0;
+#endif
 
 #ifdef HAVE_AN_ASIC
 	numasc = numascs();
@@ -2200,8 +2214,10 @@ static void edevstatus(struct io_data *io_data, __maybe_unused SOCKETTYPE c, cha
 		return;
 	}
 
+#ifdef USE_USBUTILS
 	if (param && *param)
 		howoldsec = (time_t)atoi(param);
+#endif
 
 	message(io_data, MSG_DEVS, 0, NULL, isjson);
 	if (isjson)
@@ -2506,8 +2522,8 @@ static void poolstatus(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __m
 		root = api_add_int(root, "Quota", &pool->quota, false);
 		root = api_add_string(root, "Long Poll", lp, false);
 		root = api_add_uint(root, "Getworks", &(pool->getwork_requested), false);
-		root = api_add_int(root, "Accepted", &(pool->accepted), false);
-		root = api_add_int(root, "Rejected", &(pool->rejected), false);
+		root = api_add_int64(root, "Accepted", &(pool->accepted), false);
+		root = api_add_int64(root, "Rejected", &(pool->rejected), false);
 		root = api_add_int(root, "Works", &pool->works, false);
 		root = api_add_uint(root, "Discarded", &(pool->discarded_work), false);
 		root = api_add_uint(root, "Stale", &(pool->stale_shares), false);
@@ -2515,7 +2531,7 @@ static void poolstatus(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __m
 		root = api_add_uint(root, "Remote Failures", &(pool->remotefail_occasions), false);
 		root = api_add_escape(root, "User", pool->rpc_user, false);
 		root = api_add_time(root, "Last Share Time", &(pool->last_share_time), false);
-		root = api_add_int(root, "Diff1 Shares", &(pool->diff1), false);
+		root = api_add_int64(root, "Diff1 Shares", &(pool->diff1), false);
 		if (pool->rpc_proxy) {
 			root = api_add_const(root, "Proxy Type", proxytype(pool->rpc_proxytype), false);
 			root = api_add_escape(root, "Proxy", pool->rpc_proxy, false);
@@ -2574,13 +2590,13 @@ static void summary(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __mayb
 	root = api_add_mhs(root, "MHS 5m", &rolling5, false);
 	root = api_add_mhs(root, "MHS 15m", &rolling15, false);
 	root = api_add_uint(root, "Found Blocks", &(found_blocks), true);
-	root = api_add_int(root, "Getworks", &(total_getworks), true);
-	root = api_add_int(root, "Accepted", &(total_accepted), true);
-	root = api_add_int(root, "Rejected", &(total_rejected), true);
+	root = api_add_int64(root, "Getworks", &(total_getworks), true);
+	root = api_add_int64(root, "Accepted", &(total_accepted), true);
+	root = api_add_int64(root, "Rejected", &(total_rejected), true);
 	root = api_add_int(root, "Hardware Errors", &(hw_errors), true);
 	root = api_add_utility(root, "Utility", &(utility), false);
-	root = api_add_int(root, "Discarded", &(total_discarded), true);
-	root = api_add_int(root, "Stale", &(total_stale), true);
+	root = api_add_int64(root, "Discarded", &(total_discarded), true);
+	root = api_add_int64(root, "Stale", &(total_stale), true);
 	root = api_add_uint(root, "Get Failures", &(total_go), true);
 	root = api_add_uint(root, "Local Work", &(local_work), true);
 	root = api_add_uint(root, "Remote Failures", &(total_ro), true);
@@ -3303,17 +3319,19 @@ static void minerstats(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __m
 		io_close(io_data);
 }
 
-static void minerestats(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)
+static void minerestats(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)
 {
 	struct cgpu_info *cgpu;
 	bool io_open = false;
 	struct api_data *extra;
 	char id[20];
 	int i, j;
+#ifdef USE_USBUTILS
 	time_t howoldsec = 0;
 
 	if (param && *param)
 		howoldsec = (time_t)atoi(param);
+#endif
 
 	message(io_data, MSG_MINESTATS, 0, NULL, isjson);
 	if (isjson)
diff --git a/bench_block.h b/bench_block.h
index a1aa35a..729a95e 100644
--- a/bench_block.h
+++ b/bench_block.h
@@ -1,39 +1,170 @@
-#if !defined(__BENCH_BLOCK_H__)
-	#define __BENCH_BLOCK_H__ 1
-
-	// Random work pulled from a pool
-        #define CGMINER_BENCHMARK_BLOCK                                                                         \
-                0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0xD8, 0x07, 0x17, 0xC9, 0x13, 0x6F, 0xDC, 0xBE, 0xDE, 0xB7, \
-                0xB2, 0x14, 0xEF, 0xD1, 0x72, 0x7F, 0xA3, 0x72, 0xB2, 0x5D, 0x88, 0xF0, 0x00, 0x00, 0x05, 0xAA, \
-                0x00, 0x00, 0x00, 0x00, 0x92, 0x8B, 0x4C, 0x77, 0xF5, 0xB2, 0xE6, 0x56, 0x96, 0x27, 0xE0, 0x66, \
-                0x3C, 0x5B, 0xDD, 0xDC, 0x88, 0x6A, 0x7D, 0x7C, 0x7B, 0x8C, 0xE4, 0x92, 0x38, 0x92, 0x58, 0x2E, \
-                0x18, 0x4D, 0x95, 0x9E, 0x4E, 0x44, 0xF1, 0x5F, 0x1A, 0x08, 0xE1, 0xE5, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, \
-                0x86, 0x7E, 0x3A, 0xAF, 0x37, 0x83, 0xAF, 0xA0, 0xB5, 0x33, 0x2C, 0x28, 0xED, 0xA9, 0x89, 0x3E, \
-                0x0A, 0xB6, 0x46, 0x81, 0xC2, 0x71, 0x4F, 0x34, 0x5A, 0x74, 0x89, 0x0E, 0x2B, 0x04, 0xB3, 0x16, \
-                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, \
-                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xF6, 0x09, 0x02, 0x00, 0x00, 0x00, 0x00, \
-                0x55, 0xF1, 0x44, 0x4E, 0x00, 0x00, 0x00, 0x00, 0x79, 0x63, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, \
-                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                 \
-
-#endif // !defined(__BENCH_BLOCK_H__)
+#ifndef __BENCH_BLOCK_H__
+#define __BENCH_BLOCK_H__
+
+/* This contains 32 carefully chosen work items, 16 of which return diff >= 32
+ * at nonces spaced ~ 0x10000000 apart and 16 < diff 32. */
+
+const char bench_hidiffs[16][324] = {
+// 0002108b diff 131
+"000000029c6bf469abe4ad37605c097a860cff3cf5c1ef4377618f74000000000000000082b1514e7b6565941e5824f084292164ec5f97e7ea20c494bd96e524d478977b536dd2261900896c8b100200"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"64e4e3becc01064d808269b330f40f4de82dc92e894d635025daa3e2e2c410b4",
+
+// 1003dacf diff 37
+"00000002e790c23987181950eeb144591c3ac4d06c0705f2801d097600000000000000009ebbce2f5f0d6cc0aca284ecb1059c856ef2f7f42e7edd403d246754ee4c905a536dd2a91900896ccfda0310"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"4a78daf1b5eb3397af1c00dbd9b06659cdc04183c8baaf5be1dbf32f79e00459",
+
+// 200e57b4 diff 3866
+"000000023e91fce7300a792bfbaa0c76e1aa5f9b546c1db582aee4ff0000000000000000f04650a8e748d2e6fde86a8a920b285f3e22398f583700236958323ef9ea8321536dcf431900896cb4570e20"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"0a1d654ae2b06f219ccf4601933fab408de1c3b7c8c9c85e03231d4aaf5a26cd",
+
+// 300f71e2 diff 335
+"000000023e91fce7300a792bfbaa0c76e1aa5f9b546c1db582aee4ff000000000000000074b39134c2930d2f2e7339f9d502c776c44d6ee599f7efebec6c9bbd04787aae536dce561900896ce2710f30"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"94e60c1180022f337232ab3d298f838304b6008ab237cf7e1717f1933407e592",
+
+// 400548ed diff 2670
+"000000023e91fce7300a792bfbaa0c76e1aa5f9b546c1db582aee4ff0000000000000000c5b821fb0b26d63b00cc26e7ac4d6cfd1d3fc109b0db188e7e792e3d18342919536dce501900896ced480540"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"a290eac61642949c00d17f7cd5980abedb8647fc5df9955dcfe4d56a50a0c564",
+
+// 5001f760 diff 60
+"00000002e790c23987181950eeb144591c3ac4d06c0705f2801d097600000000000000006e9d94bf5a0ab7b202d39e1200af96074e4f641f4e55e3e9e3aee72aa00a70e9536dd2ae1900896c60f70150"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"1477ca8536702eacbd65a6a162cfe90d62016a14ffe58d52b7dd4c3628a27e5b",
+
+// 600c9816 diff 35
+"00000002194bb5b4f8ac3392fbd66f3dd3e9dcdb22370e380837fe44000000000000000003bbb250f2dc23717e8192c0b8bec6a175cd059e4089d325006eaee3446254c9536dd39e1900896c16980c60"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"68db599d6b7a55fd61d4244a3dfa465055ead6b5c0a37c7a3d4555b58e99065e",
+
+// 70092d5f diff 114
+"000000023e91fce7300a792bfbaa0c76e1aa5f9b546c1db582aee4ff000000000000000072e17babd4089b204797cebda7dc6e277950eab1b2908991ae1d72335f82d204536dcf441900896c5f2d0970"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"c7d601ce3b01e569a49508d541bbcba9b3c8394b1834523ef1e5cb2c60bd34a3",
+
+// 800eeaa8 diff 159
+"000000029c6bf469abe4ad37605c097a860cff3cf5c1ef4377618f74000000000000000022388b6f022144db134af1bc8e61b385ca37cae038c1d165ae98c496b3b41e8b536dd2101900896ca8ea0e80"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"410761e97e67b494fd547cfe9ffbb36893da7aec75c6b51b8d5f38f87b5d63cf",
+
+// 900f600d diff 144
+"000000029c6bf469abe4ad37605c097a860cff3cf5c1ef4377618f7400000000000000000e1f0cfdf5ad8248fc4520f3bb0b2040226430348cddeff5ca9181beeb78870d536dd2161900896c0d600f90"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"ad1a8d354a7e8b13ec47f4c3d907d00945a61e86059f4943e42c1e52398eba5d",
+
+// a00210bf diff 1055
+"00000002194bb5b4f8ac3392fbd66f3dd3e9dcdb22370e380837fe4400000000000000002232a16d38cc0e13e4b16d917bff4c34727deb3b5c50e424fb8453ff9b2adcb4536dd4231900896cbf1002a0"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"adc67d38f31f589b18b9d8e531b994ce5733c021a03d88d38611ee6b4c2710a5",
+
+// b004309d diff 43
+"00000002194bb5b4f8ac3392fbd66f3dd3e9dcdb22370e380837fe440000000000000000a2860471277b4a93fea2a8b6d8c281fab7bde3b78f2acd1bfdc89d464ed3bb3c536dd35e1900896c9d3004b0"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"537686c611aae4397c7c04b2c190708453d00e8c9563525610c31ba46e80dbc2",
+
+// c00b7537 diff 64
+"00000002194bb5b4f8ac3392fbd66f3dd3e9dcdb22370e380837fe440000000000000000f370230607998fbbd10275c5890885fcd81b68018ba2373abf0f93a06d02ab28536dd33e1900896c37750bc0"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"1fdda952da6abd70022a6e5f2b9dc5e1b66011128c3fa249f0b7439f00d5943e",
+
+// d0005bd5 diff 1539
+"00000002c0a2c91fc41254539a5b2a27be28de2a6187e2af3f129d6300000000000000005e45ffc512d5ca3bc4d2063dd3af1669c296ae126a5a2ef896d1e190cedf67b9536dd46b1900896cd55b00d0"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"07094d6cbe76538a88612624fc5e655cc405cb8198dcad516b88dbac5bf8b906",
+
+// e00a7796 diff 41
+"00000002194bb5b4f8ac3392fbd66f3dd3e9dcdb22370e380837fe44000000000000000027c548815127c125147af91c356c293f0defbd2771f8dc3b1142b367528656db536dd37c1900896c96770ae0"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"1bdbb3b1be7216872ea787627b03c389a527451f6dd832d8540874306f9c07c6",
+
+// f001f029 diff 77
+"00000002194bb5b4f8ac3392fbd66f3dd3e9dcdb22370e380837fe440000000000000000adef758770bb90c5b13769c5b61affb322b24c747573b38ebe2ee81748d0b557536dd4071900896c29f001f0"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"1ac8eea63285353944e40eec54d2dd6cd0994b447429bb0ed0598d38f42da0e2"
+};
+
+const char bench_lodiffs[16][324] = {
+// 000ed6b6 diff 2
+"00000002c01f502cb3e9fdb053230ec12a4954c1021a6b35862b5e29000000000000000084d1b83ae44057025e8c5b5756b44f04df5fffe4a7a30e5c12d12a97a7a4c2ea536dce431900896cb6d60e00"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"d08f7e14c50dad77dc238b4db2901a0578e657b1954779ab9cd82a73829edf7f",
+
+// 1000818f diff 5
+"000000023bf53ef343a50f7599601f849c93ecce63530b0b449a44630000000000000000c1a174254a6593ffba987f68fe26e716e3c129a7f33a9c43ae7ecf90c8cd0d2c536dc4e61900896c8f810010"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"6700aeedada2b3877900b58a183c42c40949956bb8b4a8d21481f8936b572922",
+
+// 20006be9 diff 7
+"00000002138cf4b61dff74e3c26b2d80045064e8ab4802521bab2cda000000000000000071eef64a7ef4e47cda16e96673197d36c7235a4aadd23c21a38ce53827d1f8bc536dc4d71900896ce96b0020"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"0730cf7a6b8a85eb1cc017b109d23c392464f99aa8c020ea107c525b671adde0",
+
+// 300029f4 diff 2
+"000000023bf53ef343a50f7599601f849c93ecce63530b0b449a44630000000000000000fe2c6b926468565e524ab7c2f111035dcde7c60955842111930589eccb410f83536dc66b1900896cf4290030"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"27dbb374a97f15c59587256662f36904d075d0e61f749618182711288ac617c7",
+
+// 40001d82 diff 2
+"000000023bf53ef343a50f7599601f849c93ecce63530b0b449a4463000000000000000003073385e05c29f0435a6001c8eca9c8d5602890aeff9d4d103d3383cf80dae5536dc57c1900896c821d0040"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"7da3b97e82c0c3125a58dad8a0d1d0369244731f3b096e972484298d15b843d9",
+
+// 50003ce6 diff 1
+"000000029ca55e5f1bc0328c84f358fddadc13cb232599bc2ca9dbe10000000000000000b5b4d19c20a7fc2b174ff673c006edd2247c4b2336571864df93eb7ec0c8c276536dfe041900896ce63c0050"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"1514bd586511e531e2b6277a6d112b171f9e008d56ef4a971e619acf22e75072",
+
+// 60004314 diff 2
+"000000023bf53ef343a50f7599601f849c93ecce63530b0b449a446300000000000000003e3030629ff4258056dc9efaf922bd173a65f65ee799b0c765097d3deeddef10536dc4d81900896c14430060"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"dcb77a9c36d894d2dbc31437e5c2a1564e927937848ea2eb20b38638afc64b96",
+
+// 700041d4 diff 7
+"000000023bf53ef343a50f7599601f849c93ecce63530b0b449a446300000000000000005513c22bb99e9daa9936b0df5dce64d7737e3706be99e5098d112002492cf81b536dc5691900896cd4410070"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"0d896267fda5dda0f85308e77f754c8b94b7b88e3cb315475cd9efd16401e3ce",
+
+// 80009d99 diff 1
+"00000002e155f07e652e4d671ca4db51bbde14d2b5ae34ee67ecc74400000000000000004af5cffd7e5a7087f1b484b526c7350c86d8389283509ca878502f792115e8dc536dc6ad1900896c999d0080"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"339354568f506ac3cd69bb427b1af83a0473b87c16bf3b562a93d0a2ffc53e54",
+
+//  9000fb14 diff 4
+"000000029ca55e5f1bc0328c84f358fddadc13cb232599bc2ca9dbe100000000000000005925a624e5c84f96d2c34dce3b6a736addb891724b48a36320c7494435f9c915536dfe621900896c14fb0090"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"8362009c07cf48249f481be6b79e67247cab1d20050cf11c276085b90732110c",
+
+// a000eb5e diff 2
+"00000002e155f07e652e4d671ca4db51bbde14d2b5ae34ee67ecc74400000000000000001e69f1d6507f4b7b50980930f7d8089834fbe65f0980b8592d53cdda08e50d24536dc7da1900896c5eeb00a0"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"21e4f654d26ab8c9164ff311657a9f9c4cdc0e8a09334925f7c02138819d7e61",
+
+// b0002ec5 diff 2
+"000000023bf53ef343a50f7599601f849c93ecce63530b0b449a4463000000000000000064923b63f53c72c04ebe6c1c9140b6377132b6e50865814fe562291bd023d348536dc65a1900896cc52e00b0"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"55db91a25401a89daf9ff7d7954bab722b894ba480fefaf1f0a95aaf5f600567",
+
+// c0001f6e diff 2
+"000000023bf53ef343a50f7599601f849c93ecce63530b0b449a44630000000000000000ee9817160e35d4410601c8dc741c1a810c485f3b40a0859be5f58f0bf6ef1694536dc6321900896c6e1f00c0"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"ae215785178ff6350064060ebbb219a71716a10e88528fc4bb1cb5c8fdd0cf60",
+
+// d0005f26 diff 7
+"000000029ca55e5f1bc0328c84f358fddadc13cb232599bc2ca9dbe100000000000000001e514cf738455a54f004ec86edafcfd9fd2022017bb31c245340353911744fb7536dfe1f1900896c265f00d0"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"dcafaa86defe850b057ae74f7218a79b0ede086a196f18f0e7c585eb88d1139a",
+
+// e0008993 diff 2
+"000000023bf53ef343a50f7599601f849c93ecce63530b0b449a446300000000000000005edbd53fcc64850b5334678199d769514818fbcc79861fc77e572bb4753b7fe2536dc5d91900896c938900e0"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"5e653df5956ece518a78a5d11297431af94ce8ba91d80cfb2aa8c5b3095fa256",
+
+// f000709e diff 1
+"000000023bf53ef343a50f7599601f849c93ecce63530b0b449a44630000000000000000596fc4aa5da839ba267c36aa1a5b29d813747b2273dc03aa9e404c4da0238e2b536dc4cc1900896c9e7000f0"
+"000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"
+"0e23806a533bd956787eef52dd8edee456c60d6cecbb6175458ee53fc8c6c813"
+};
+#endif /* __BENCH_BLOCK_H__ */
diff --git a/cgminer.c b/cgminer.c
index f044b1d..a2be32a 100644
--- a/cgminer.c
+++ b/cgminer.c
@@ -238,6 +238,9 @@ static char *opt_set_bitmain_freq;
 static char *opt_set_hfa_fan;
 #endif
 static char *opt_set_null;
+#ifdef USE_MINION
+char *opt_minion_freq;
+#endif
 
 #ifdef USE_USBUTILS
 char *opt_usb_select = NULL;
@@ -309,8 +312,8 @@ cglock_t control_lock;
 pthread_mutex_t stats_lock;
 
 int hw_errors;
-int total_accepted, total_rejected, total_diff1;
-int total_getworks, total_stale, total_discarded;
+int64_t total_accepted, total_rejected, total_diff1;
+int64_t total_getworks, total_stale, total_discarded;
 double total_diff_accepted, total_diff_rejected, total_diff_stale;
 static int staged_rollable;
 unsigned int new_blocks;
@@ -737,6 +740,11 @@ static char *set_int_1_to_10(const char *arg, int *i)
 	return set_int_range(arg, i, 1, 10);
 }
 
+static char __maybe_unused *set_int_0_to_4(const char *arg, int *i)
+{
+	return set_int_range(arg, i, 0, 4);
+}
+
 #ifdef USE_FPGA_SERIAL
 static char *opt_add_serial;
 static char *add_serial(char *arg)
@@ -764,10 +772,10 @@ static char *set_loadbalance(enum pool_strategy *strategy)
 	return NULL;
 }
 
-static char *set_rotate(const char *arg, int *i)
+static char *set_rotate(const char *arg, char __maybe_unused *i)
 {
 	pool_strategy = POOL_ROTATE;
-	return set_int_range(arg, i, 0, 9999);
+	return set_int_range(arg, &opt_rotate_period, 0, 9999);
 }
 
 static char *set_rr(enum pool_strategy *strategy)
@@ -1103,12 +1111,18 @@ static struct opt_table opt_config_table[] = {
 	OPT_WITH_CBARG("--avalon2-freq",
 		     set_avalon2_freq, NULL, &opt_set_avalon2_freq,
 		     "Set frequency range for Avalon2, single value or range"),
-	OPT_WITH_CBARG("--avalon2-fan",
-		     set_avalon2_fan, NULL, &opt_set_avalon2_fan,
-		     "Set Avalon2 target fan speed"),
 	OPT_WITH_CBARG("--avalon2-voltage",
 		     set_avalon2_voltage, NULL, &opt_set_avalon2_voltage,
 		     "Set Avalon2 core voltage, in millivolts"),
+	OPT_WITH_CBARG("--avalon2-fan",
+		     set_avalon2_fan, NULL, &opt_set_avalon2_fan,
+		     "Set Avalon2 target fan speed"),
+	OPT_WITH_ARG("--avalon2-cutoff",
+		     set_int_0_to_100, opt_show_intval, &opt_avalon2_overheat,
+		     "Set Avalon2 overheat cut off temperature"),
+	OPT_WITHOUT_ARG("--avalon2-fixed-speed",
+		     set_avalon2_fixed_speed, &opt_avalon2_fan_fixed,
+		     "Set Avalon2 fan to fixed speed"),
 #endif
 #ifdef USE_BAB
 	OPT_WITH_ARG("--bab-options",
@@ -1180,6 +1194,9 @@ static struct opt_table opt_config_table[] = {
 	OPT_WITH_ARG("--bxf-bits",
 		     set_int_32_to_63, opt_show_intval, &opt_bxf_bits,
 		     "Set max BXF/HXF bits for overclocking"),
+	OPT_WITH_ARG("--bxf-debug",
+		     set_int_0_to_4, opt_show_intval, &opt_bxf_debug,
+		    "BXF: Debug all USB I/O, > is to the board(s), < is from the board(s)"),
 	OPT_WITH_ARG("--bxf-temp-target",
 		     set_int_0_to_200, opt_show_intval, &opt_bxf_temp_target,
 		     "Set target temperature for BXF/HXF devices"),
@@ -1301,6 +1318,11 @@ static struct opt_table opt_config_table[] = {
 	OPT_WITHOUT_ARG("--lowmem",
 			opt_set_bool, &opt_lowmem,
 			"Minimise caching of shares for low memory applications"),
+#ifdef USE_MINION
+	OPT_WITH_ARG("--minion-freq",
+		     opt_set_charp, NULL, &opt_minion_freq,
+		     "Set minion chip frequencies in MHz, single value or comma list, range 100-1400 (default: 1000)"),
+#endif
 #if defined(unix) || defined(__APPLE__)
 	OPT_WITH_ARG("--monitor|-m",
 		     opt_set_charp, NULL, &opt_stderr_cmd,
@@ -1308,7 +1330,7 @@ static struct opt_table opt_config_table[] = {
 #endif // defined(unix)
 #ifdef USE_BITFURY
 	OPT_WITH_ARG("--nfu-bits",
-		     set_int_32_to_63, opt_show_intval, &opt_nf1_bits,
+		     set_int_32_to_63, opt_show_intval, &opt_nfu_bits,
 		     "Set nanofury bits for overclocking, range 32-63"),
 #endif
 	OPT_WITHOUT_ARG("--net-delay",
@@ -1320,6 +1342,11 @@ static struct opt_table opt_config_table[] = {
 	OPT_WITHOUT_ARG("--no-submit-stale",
 			opt_set_invbool, &opt_submit_stale,
 		        "Don't submit shares if they are detected as stale"),
+#ifdef USE_BITFURY
+	OPT_WITH_ARG("--osm-led-mode",
+		     set_int_0_to_4, opt_show_intval, &opt_osm_led_mode,
+		     "Set LED mode for OneStringMiner devices"),
+#endif
 	OPT_WITH_ARG("--pass|-p",
 		     set_pass, NULL, &opt_set_null,
 		     "Password for bitcoin JSON-RPC server"),
@@ -1350,7 +1377,7 @@ static struct opt_table opt_config_table[] = {
 		     set_null, NULL, &opt_set_null,
 		     opt_hidden),
 	OPT_WITH_ARG("--rotate",
-		     set_rotate, opt_show_intval, &opt_rotate_period,
+		     set_rotate, NULL, &opt_set_null,
 		     "Change multipool strategy from failover to regularly rotate at N minutes"),
 	OPT_WITHOUT_ARG("--round-robin",
 		     set_rr, &pool_strategy,
@@ -1761,7 +1788,7 @@ void clean_work(struct work *work)
 
 /* All dynamically allocated work structs should be freed here to not leak any
  * ram from arrays allocated within the work struct */
-void free_work(struct work *work)
+void _free_work(struct work *work)
 {
 	clean_work(work);
 	free(work);
@@ -1890,7 +1917,6 @@ static void gen_gbt_work(struct pool *pool, struct work *work)
 	local_work++;
 	work->pool = pool;
 	work->gbt = true;
-	work->id = total_work_inc();
 	work->longpoll = false;
 	work->getwork_mode = GETWORK_MODE_GBT;
 	work->work_block = work_block;
@@ -2526,12 +2552,12 @@ static void curses_print_status(void)
 	wclrtoeol(statuswin);
 	if (opt_widescreen) {
 		cg_mvwprintw(statuswin, 3, 0, " A:%.0f  R:%.0f  HW:%d  WU:%.1f/m |"
-			     " ST: %d  SS: %d  NB: %d  LW: %d  GF: %d  RF: %d",
+			     " ST: %d  SS: %"PRId64"  NB: %d  LW: %d  GF: %d  RF: %d",
 			     total_diff_accepted, total_diff_rejected, hw_errors,
 			     total_diff1 / total_secs * 60,
 			     total_staged(), total_stale, new_blocks, local_work, total_go, total_ro);
 	} else if (alt_status) {
-		cg_mvwprintw(statuswin, 3, 0, " ST: %d  SS: %d  NB: %d  LW: %d  GF: %d  RF: %d",
+		cg_mvwprintw(statuswin, 3, 0, " ST: %d  SS: %"PRId64"  NB: %d  LW: %d  GF: %d  RF: %d",
 			     total_staged(), total_stale, new_blocks, local_work, total_go, total_ro);
 	} else {
 		cg_mvwprintw(statuswin, 3, 0, " A:%.0f  R:%.0f  HW:%d  WU:%.1f/m",
@@ -3440,22 +3466,22 @@ static void calc_diff(struct work *work, double known)
 	}
 }
 
+static unsigned char bench_hidiff_bins[16][160];
+static unsigned char bench_lodiff_bins[16][160];
+static unsigned char bench_target[32];
+
+/* Iterate over the lo and hi diff benchmark work items such that we find one
+ * diff 32+ share every 32 work items. */
 static void get_benchmark_work(struct work *work)
 {
-	// Use a random work block pulled from a pool
-	static uint8_t bench_block[] = { CGMINER_BENCHMARK_BLOCK };
-
-	size_t bench_size = sizeof(*work);
-	size_t work_size = sizeof(bench_block);
-	size_t min_size = (work_size < bench_size ? work_size : bench_size);
-	memset(work, 0, sizeof(*work));
-	memcpy(work, &bench_block, min_size);
+	work->work_difficulty = 32;
+	memcpy(work->target, bench_target, 32);
+	work->drv_rolllimit = 0;
 	work->mandatory = true;
 	work->pool = pools[0];
 	cgtime(&work->tv_getwork);
 	copy_time(&work->tv_getwork_reply, &work->tv_getwork);
 	work->getwork_mode = GETWORK_MODE_BENCHMARK;
-	calc_diff(work, 0);
 }
 
 static void benchfile_dspwork(struct work *work, uint32_t nonce)
@@ -3977,7 +4003,12 @@ struct work *make_clone(struct work *work)
 	return work_clone;
 }
 
-static void stage_work(struct work *work);
+static void _stage_work(struct work *work);
+
+#define stage_work(WORK) do { \
+	_stage_work(WORK); \
+	WORK = NULL; \
+} while (0)
 
 static bool clone_available(void)
 {
@@ -4127,6 +4158,16 @@ struct work *copy_work_noffset(struct work *base_work, int noffset)
 	return work;
 }
 
+void pool_failed(struct pool *pool)
+{
+	if (!pool_tset(pool, &pool->idle)) {
+		cgtime(&pool->tv_idle);
+		if (pool == current_pool()) {
+			switch_pools(NULL);
+		}
+	}
+}
+
 static void pool_died(struct pool *pool)
 {
 	if (!pool_tset(pool, &pool->idle)) {
@@ -4362,7 +4403,7 @@ void switch_pools(struct pool *selected)
 
 }
 
-void discard_work(struct work *work)
+void _discard_work(struct work *work)
 {
 	if (!work->clone && !work->rolls && !work->mined) {
 		if (work->pool) {
@@ -4705,7 +4746,7 @@ static bool hash_push(struct work *work)
 	return rc;
 }
 
-static void stage_work(struct work *work)
+static void _stage_work(struct work *work)
 {
 	applog(LOG_DEBUG, "Pushing work from pool %d to hash queue", work->pool->pool_no);
 	work->work_block = work_block;
@@ -4743,9 +4784,9 @@ static void display_pool_summary(struct pool *pool)
 		if (!pool->has_stratum)
 			wlog("%s own long-poll support\n", pool->hdr_path ? "Has" : "Does not have");
 		wlog(" Queued work requests: %d\n", pool->getwork_requested);
-		wlog(" Share submissions: %d\n", pool->accepted + pool->rejected);
-		wlog(" Accepted shares: %d\n", pool->accepted);
-		wlog(" Rejected shares: %d\n", pool->rejected);
+		wlog(" Share submissions: %"PRId64"\n", pool->accepted + pool->rejected);
+		wlog(" Accepted shares: %"PRId64"\n", pool->accepted);
+		wlog(" Rejected shares: %"PRId64"\n", pool->rejected);
 		wlog(" Accepted difficulty shares: %1.f\n", pool->diff_accepted);
 		wlog(" Rejected difficulty shares: %1.f\n", pool->diff_rejected);
 		if (pool->accepted || pool->rejected)
@@ -5496,7 +5537,7 @@ retry:
 		wlogprint("Hardware Errors %d\n", cgpu->hw_errors);
 		wlogprint("Last Share Pool %d\n", cgpu->last_share_pool_time > 0 ? cgpu->last_share_pool : -1);
 		wlogprint("Total MH %.1f\n", cgpu->total_mhashes);
-		wlogprint("Diff1 Work %d\n", cgpu->diff1);
+		wlogprint("Diff1 Work %"PRId64"\n", cgpu->diff1);
 		wlogprint("Difficulty Accepted %.1f\n", cgpu->diff_accepted);
 		wlogprint("Difficulty Rejected %.1f\n", cgpu->diff_rejected);
 		wlogprint("Last Share Difficulty %.1f\n", cgpu->last_share_diff);
@@ -6077,6 +6118,7 @@ static void *stratum_rthread(void *userdata)
 			if (!restart_stratum(pool)) {
 				pool_died(pool);
 				while (!restart_stratum(pool)) {
+					pool_failed(pool);
 					if (pool->removed)
 						goto out;
 					cgsleep_ms(30000);
@@ -6117,6 +6159,7 @@ static void *stratum_rthread(void *userdata)
 
 			pool_died(pool);
 			while (!restart_stratum(pool)) {
+				pool_failed(pool);
 				if (pool->removed)
 					goto out;
 				cgsleep_ms(30000);
@@ -6723,18 +6766,28 @@ void set_target(unsigned char *dest_target, double diff)
 }
 
 #ifdef USE_AVALON2
-void submit_nonce2_nonce(struct thr_info *thr, uint32_t pool_no, uint32_t nonce2, uint32_t nonce)
+void submit_nonce2_nonce(struct thr_info *thr, struct pool *pool, struct pool *real_pool,
+			 uint32_t nonce2, uint32_t nonce)
 {
+	const int thr_id = thr->id;
 	struct cgpu_info *cgpu = thr->cgpu;
 	struct device_drv *drv = cgpu->drv;
-
-	struct pool *pool = pools[pool_no];
 	struct work *work = make_work();
 
+	cg_wlock(&pool->data_lock);
 	pool->nonce2 = nonce2;
+	cg_wunlock(&pool->data_lock);
+
 	gen_stratum_work(pool, work);
+	work->pool = real_pool;
+
+	work->thr_id = thr_id;
+	work->work_block = work_block;
+	work->pool->works++;
+
+	work->mined = true;
+	work->device_diff = MIN(cgpu->drv->max_diff, work->work_difficulty);
 
-	work->device_diff = MIN(drv->working_diff, work->work_difficulty);
 	submit_nonce(thr, work, nonce);
 	free_work(work);
 }
@@ -6808,7 +6861,6 @@ static void gen_stratum_work(struct pool *pool, struct work *work)
 	work->pool = pool;
 	work->stratum = true;
 	work->nonce = 0;
-	work->id = total_work_inc();
 	work->longpoll = false;
 	work->getwork_mode = GETWORK_MODE_STRATUM;
 	work->work_block = work_block;
@@ -6950,7 +7002,6 @@ static void gen_solo_work(struct pool *pool, struct work *work)
 	work->gbt = true;
 	work->pool = pool;
 	work->nonce = 0;
-	work->id = total_work_inc();
 	work->longpoll = false;
 	work->getwork_mode = GETWORK_MODE_SOLO;
 	work->work_block = work_block;
@@ -6969,8 +7020,23 @@ int share_work_tdiff(struct cgpu_info *cgpu)
 	return last_getwork - cgpu->last_device_valid_work;
 }
 
+static void set_benchmark_work(struct cgpu_info *cgpu, struct work *work)
+{
+	cgpu->lodiff += cgpu->direction;
+	if (cgpu->lodiff < 1)
+		cgpu->direction = 1;
+	if (cgpu->lodiff > 15) {
+		cgpu->direction = -1;
+		if (++cgpu->hidiff > 15)
+			cgpu->hidiff = 0;
+		memcpy(work, &bench_hidiff_bins[cgpu->hidiff][0], 160);
+	} else
+		memcpy(work, &bench_lodiff_bins[cgpu->lodiff][0], 160);
+}
+
 struct work *get_work(struct thr_info *thr, const int thr_id)
 {
+	struct cgpu_info *cgpu = thr->cgpu;
 	struct work *work = NULL;
 	time_t diff_t;
 
@@ -6981,7 +7047,6 @@ struct work *get_work(struct thr_info *thr, const int thr_id)
 		work = hash_pop(true);
 		if (stale_work(work, false)) {
 			discard_work(work);
-			work = NULL;
 			wake_gws();
 		}
 	}
@@ -6991,14 +7056,17 @@ struct work *get_work(struct thr_info *thr, const int thr_id)
 	 * device failures. */
 	if (diff_t > 0) {
 		applog(LOG_DEBUG, "Get work blocked for %d seconds", (int)diff_t);
-		thr->cgpu->last_device_valid_work += diff_t;
+		cgpu->last_device_valid_work += diff_t;
 	}
 	applog(LOG_DEBUG, "Got work from get queue to get work for thread %d", thr_id);
 
 	work->thr_id = thr_id;
+	if (opt_benchmark)
+		set_benchmark_work(cgpu, work);
+
 	thread_reportin(thr);
 	work->mined = true;
-	work->device_diff = MIN(thr->cgpu->drv->max_diff, work->work_difficulty);
+	work->device_diff = MIN(cgpu->drv->max_diff, work->work_difficulty);
 	return work;
 }
 
@@ -7009,6 +7077,22 @@ static void submit_work_async(struct work *work)
 	pthread_t submit_thread;
 
 	cgtime(&work->tv_work_found);
+	if (opt_benchmark) {
+		struct cgpu_info *cgpu = get_thr_cgpu(work->thr_id);
+
+		mutex_lock(&stats_lock);
+		cgpu->accepted++;
+		total_accepted++;
+		pool->accepted++;
+		cgpu->diff_accepted += work->work_difficulty;
+		total_diff_accepted += work->work_difficulty;
+		pool->diff_accepted += work->work_difficulty;
+		mutex_unlock(&stats_lock);
+
+		applog(LOG_NOTICE, "Accepted %s %d benchmark share nonce %08x",
+		       cgpu->drv->name, cgpu->device_id, *(uint32_t *)(work->data + 64 + 12));
+		return;
+	}
 
 	if (stale_work(work, true)) {
 		if (opt_submit_stale)
@@ -7156,16 +7240,18 @@ bool submit_noffset_nonce(struct thr_info *thr, struct work *work_in, uint32_t n
 
 	_copy_work(work, work_in, noffset);
 	if (!test_nonce(work, nonce)) {
+		free_work(work);
 		inc_hw_errors(thr);
 		goto out;
 	}
-	ret = true;
 	update_work_stats(thr, work);
 
 	if (opt_benchfile && opt_benchfile_display)
 		benchfile_dspwork(work, nonce);
 
+	ret = true;
 	if (!fulltest(work->hash, work->target)) {
+		free_work(work);
 		applog(LOG_INFO, "%s %d: Share above target", thr->cgpu->drv->name,
 		       thr->cgpu->device_id);
 		goto  out;
@@ -7173,8 +7259,6 @@ bool submit_noffset_nonce(struct thr_info *thr, struct work *work_in, uint32_t n
 	submit_work_async(work);
 
 out:
-	if (!ret)
-		free_work(work);
 	return ret;
 }
 
@@ -7235,7 +7319,7 @@ static void hash_sole_work(struct thr_info *mythr)
 				"mining thread %d", thr_id);
 			break;
 		}
-		work->device_diff = MIN(drv->working_diff, work->work_difficulty);
+		work->device_diff = MIN(drv->max_diff, work->work_difficulty);
 
 		do {
 			cgtime(&tv_start);
@@ -7401,7 +7485,6 @@ struct work *get_queued(struct cgpu_info *cgpu)
 		work = cgpu->unqueued_work;
 		if (unlikely(stale_work(work, false))) {
 			discard_work(work);
-			work = NULL;
 			wake_gws();
 		} else
 			__add_queued(cgpu, work);
@@ -7526,6 +7609,7 @@ int age_queued_work(struct cgpu_info *cgpu, double secs)
 	HASH_ITER(hh, cgpu->queued_work, work, tmp) {
 		if (tdiff(&tv_now, &work->tv_work_start) > secs) {
 			__work_completed(cgpu, work);
+			free_work(work);
 			aged++;
 		}
 	}
@@ -8110,10 +8194,10 @@ static void *watchpool_thread(void __maybe_unused *userdata)
 
 			/* Get a rolling utility per pool over 10 mins */
 			if (intervals > 19) {
-				int shares = pool->diff1 - pool->last_shares;
+				double shares = pool->diff1 - pool->last_shares;
 
 				pool->last_shares = pool->diff1;
-				pool->utility = (pool->utility + (double)shares * 0.63) / 1.63;
+				pool->utility = (pool->utility + shares * 0.63) / 1.63;
 				pool->shares = pool->utility;
 			}
 
@@ -8353,9 +8437,9 @@ void print_summary(void)
 	applog(LOG_WARNING, "Average hashrate: %.1f Mhash/s", displayed_hashes);
 	applog(LOG_WARNING, "Solved blocks: %d", found_blocks);
 	applog(LOG_WARNING, "Best share difficulty: %s", best_share);
-	applog(LOG_WARNING, "Share submissions: %d", total_accepted + total_rejected);
-	applog(LOG_WARNING, "Accepted shares: %d", total_accepted);
-	applog(LOG_WARNING, "Rejected shares: %d", total_rejected);
+	applog(LOG_WARNING, "Share submissions: %"PRId64, total_accepted + total_rejected);
+	applog(LOG_WARNING, "Accepted shares: %"PRId64, total_accepted);
+	applog(LOG_WARNING, "Rejected shares: %"PRId64, total_rejected);
 	applog(LOG_WARNING, "Accepted difficulty shares: %1.f", total_diff_accepted);
 	applog(LOG_WARNING, "Rejected difficulty shares: %1.f", total_diff_rejected);
 	if (total_accepted || total_rejected)
@@ -8364,7 +8448,7 @@ void print_summary(void)
 	applog(LOG_WARNING, "Utility (accepted shares / min): %.2f/min", utility);
 	applog(LOG_WARNING, "Work Utility (diff1 shares solved / min): %.2f/min\n", work_util);
 
-	applog(LOG_WARNING, "Stale submissions discarded due to new blocks: %d", total_stale);
+	applog(LOG_WARNING, "Stale submissions discarded due to new blocks: %"PRId64, total_stale);
 	applog(LOG_WARNING, "Unable to get work from server occasions: %d", total_go);
 	applog(LOG_WARNING, "Work items generated locally: %d", local_work);
 	applog(LOG_WARNING, "Submitting work remotely delay occasions: %d", total_ro);
@@ -8377,9 +8461,9 @@ void print_summary(void)
 			applog(LOG_WARNING, "Pool: %s", pool->rpc_url);
 			if (pool->solved)
 				applog(LOG_WARNING, "SOLVED %d BLOCK%s!", pool->solved, pool->solved > 1 ? "S" : "");
-			applog(LOG_WARNING, " Share submissions: %d", pool->accepted + pool->rejected);
-			applog(LOG_WARNING, " Accepted shares: %d", pool->accepted);
-			applog(LOG_WARNING, " Rejected shares: %d", pool->rejected);
+			applog(LOG_WARNING, " Share submissions: %"PRId64, pool->accepted + pool->rejected);
+			applog(LOG_WARNING, " Accepted shares: %"PRId64, pool->accepted);
+			applog(LOG_WARNING, " Rejected shares: %"PRId64, pool->rejected);
 			applog(LOG_WARNING, " Accepted difficulty shares: %1.f", pool->diff_accepted);
 			applog(LOG_WARNING, " Rejected difficulty shares: %1.f", pool->diff_rejected);
 			if (pool->accepted || pool->rejected)
@@ -8819,8 +8903,6 @@ void fill_device_drv(struct device_drv *drv)
 		drv->zero_stats = &noop_zero_stats;
 	if (!drv->max_diff)
 		drv->max_diff = 1;
-	if (!drv->working_diff)
-		drv->working_diff = 1;
 }
 
 void null_device_drv(struct device_drv *drv)
@@ -8856,7 +8938,6 @@ void null_device_drv(struct device_drv *drv)
 
 	drv->zero_stats = &noop_zero_stats;
 	drv->max_diff = 1;
-	drv->working_diff = 1;
 }
 
 void enable_device(struct cgpu_info *cgpu)
@@ -8917,6 +8998,11 @@ bool add_cgpu(struct cgpu_info *cgpu)
 		devices[total_devices++] = cgpu;
 
 	adjust_mostdevs();
+#ifdef USE_USBUTILS
+	if (cgpu->usbdev && !cgpu->unique_id && cgpu->usbdev->serial_string &&
+	    strlen(cgpu->usbdev->serial_string) > 4)
+		cgpu->unique_id = str_text(cgpu->usbdev->serial_string);
+#endif
 	return true;
 }
 
@@ -9000,7 +9086,9 @@ static void hotplug_process(void)
 	wr_unlock(&mining_thr_lock);
 
 	adjust_mostdevs();
+#ifdef HAVE_CURSES
 	switch_logsize(true);
+#endif
 }
 
 #define DRIVER_DRV_DETECT_HOTPLUG(X) X##_drv.drv_detect(true);
@@ -9096,6 +9184,7 @@ static void initialise_usb(void) {
 int main(int argc, char *argv[])
 {
 	struct sigaction handler;
+	struct work *work = NULL;
 	bool pool_msg = false;
 	struct thr_info *thr;
 	struct block *block;
@@ -9212,6 +9301,12 @@ int main(int argc, char *argv[])
 		enable_pool(pool);
 		pool->idle = false;
 		successful_connect = true;
+
+		for (i = 0; i < 16; i++) {
+			hex2bin(&bench_hidiff_bins[i][0], &bench_hidiffs[i][0], 160);
+			hex2bin(&bench_lodiff_bins[i][0], &bench_lodiffs[i][0], 160);
+		}
+		set_target(bench_target, 32);
 	}
 
 #ifdef HAVE_CURSES
@@ -9501,7 +9596,6 @@ begin_bench:
 		int ts, max_staged = max_queue;
 		struct pool *pool, *cp;
 		bool lagging = false;
-		struct work *work;
 
 		if (opt_work_update)
 			signal_work_update();
@@ -9546,6 +9640,8 @@ begin_bench:
 			continue;
 		}
 
+		if (work)
+			discard_work(work);
 		work = make_work();
 
 		if (lagging && !pool_tset(cp, &cp->lagging)) {
@@ -9638,6 +9734,7 @@ retry:
 			cgsleep_ms(5000);
 			push_curl_entry(ce, pool);
 			pool = select_pool(!opt_fail_only);
+			free_work(work);
 			goto retry;
 		}
 		if (ts >= max_staged)
diff --git a/compat/libusb-1.0/libusb/io.c b/compat/libusb-1.0/libusb/io.c
index f488478..55b17f1 100644
--- a/compat/libusb-1.0/libusb/io.c
+++ b/compat/libusb-1.0/libusb/io.c
@@ -1478,7 +1478,10 @@ int usbi_handle_transfer_completion(struct usbi_transfer *itransfer,
 	 * the shortest timeout. */
 
 	usbi_mutex_lock(&ctx->flying_transfers_lock);
-	list_del(&itransfer->list);
+	/* FIXME: Sanity check for some race where this entry has already been
+	 * removed! */
+	if ((&itransfer->list)->next)
+		list_del(&itransfer->list);
 	if (usbi_using_timerfd(ctx)) {
 		r = arm_timerfd_for_next_timeout(ctx);
 		if (0 == r)
diff --git a/configure.ac b/configure.ac
index 5d6bb3b..20c41bd 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2,7 +2,7 @@
 ##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##
 m4_define([v_maj], [4])
 m4_define([v_min], [3])
-m4_define([v_mic], [0])
+m4_define([v_mic], [3])
 ##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##--##
 m4_define([v_ver], [v_maj.v_min.v_mic])
 m4_define([lt_rev], m4_eval(v_maj + v_min))
@@ -106,13 +106,6 @@ case $target in
 	;;
 esac
 
-have_cgminer_sdk=false
-if test -n "$CGMINER_SDK"; then
-	have_cgminer_sdk=true
-	CPPFLAGS="-I$CGMINER_SDK/include $CPPFLAGS"
-	LDFLAGS="-L$CGMINER_SDK/lib/$target $LDFLAGS"
-fi
-
 has_winpthread=false
 if test "x$have_win32" = xtrue; then
         has_winpthread=true
diff --git a/driver-SPI-bitmine-A1.c b/driver-SPI-bitmine-A1.c
index 8ba4a6e..2ac50db 100644
--- a/driver-SPI-bitmine-A1.c
+++ b/driver-SPI-bitmine-A1.c
@@ -21,37 +21,14 @@
 #include "miner.h"
 #include "util.h"
 
-///////////////////////////////////////////////////////////////////////////
-#if 1
-#define MAX_BOARDS 5
-
-/*
- * TODO: yes, we include a C file for now until we set up a framework
- * to support different variants of A1 products
- */
-#include "A1-desk-board-selector-tca9535.c"
-#else
-#define MAX_BOARDS 1
-bool a1_board_selector_init() { return true; }
-void a1_board_selector_exit() {}
-void a1_board_selector_reset_all_boards() {}
-void a1_board_selector_select_board(uint8_t b) {};
-void unlock_board_selector() {}
-#endif
-///////////////////////////////////////////////////////////////////////////
+#include "A1-common.h"
+#include "A1-board-selector.h"
+#include "A1-trimpot-mcp4x.h"
 
+/* one global board_selector is enough */
+static struct board_selector *board_selector;
 
 /********** work queue */
-struct work_ent {
-	struct work *work;
-	struct list_head head;
-};
-
-struct work_queue {
-	int num_elems;
-	struct list_head head;
-};
-
 static bool wq_enqueue(struct work_queue *wq, struct work *work)
 {
 	if (work == NULL)
@@ -82,7 +59,6 @@ static struct work *wq_dequeue(struct work_queue *wq)
 	return work;
 }
 
-/********** chip and chain context structures */
 /*
  * if not cooled sufficiently, communication fails and chip is temporary
  * disabled. we let it inactive for 30 seconds to cool down
@@ -91,52 +67,8 @@ static struct work *wq_dequeue(struct work_queue *wq)
  */
 #define COOLDOWN_MS (30 * 1000)
 /* if after this number of retries a chip is still inaccessible, disable it */
-#define DISABLE_CHIP_FAIL_THRESHOLD	7
+#define DISABLE_CHIP_FAIL_THRESHOLD	3
 
-/* the WRITE_JOB command is the largest (2 bytes command, 56 bytes payload) */
-#define WRITE_JOB_LENGTH	58
-#define MAX_CHAIN_LENGTH	64
-/*
- * For commands to traverse the chain, we need to issue dummy writes to
- * keep SPI clock running. To reach the last chip in the chain, we need to
- * write the command, followed by chain-length words to pass it through the
- * chain and another chain-length words to get the ACK back to host
- */
-#define MAX_CMD_LENGTH		(WRITE_JOB_LENGTH + MAX_CHAIN_LENGTH * 2 * 2)
-
-struct A1_chip {
-	int num_cores;
-	int last_queued_id;
-	struct work *work[4];
-	/* stats */
-	int hw_errors;
-	int stales;
-	int nonces_found;
-	int nonce_ranges_done;
-
-	/* systime in ms when chip was disabled */
-	int cooldown_begin;
-	/* number of consecutive failures to access the chip */
-	int fail_count;
-	/* mark chip disabled, do not try to re-enable it */
-	bool disabled;
-};
-
-struct A1_chain {
-	int board_id;
-	struct cgpu_info *cgpu;
-	int num_chips;
-	int num_cores;
-	int num_active_chips;
-	int chain_skew;
-	uint8_t spi_tx[MAX_CMD_LENGTH];
-	uint8_t spi_rx[MAX_CMD_LENGTH];
-	struct spi_ctx *spi_ctx;
-	struct A1_chip *chips;
-	pthread_mutex_t lock;
-
-	struct work_queue active_wq;
-};
 
 enum A1_command {
 	A1_BIST_START		= 0x01,
@@ -149,21 +81,12 @@ enum A1_command {
 	A1_READ_REG_RESP	= 0x1a,
 };
 
-/********** config paramters */
-struct A1_config_options {
-	int ref_clk_khz;
-	int sys_clk_khz;
-	int spi_clk_khz;
-	/* limit chip chain to this number of chips (testing only) */
-	int override_chip_num;
-};
-
 /*
  * for now, we have one global config, defaulting values:
  * - ref_clk 16MHz / sys_clk 800MHz
  * - 2000 kHz SPI clock
  */
-static struct A1_config_options config_options = {
+struct A1_config_options A1_config_options = {
 	.ref_clk_khz = 16000, .sys_clk_khz = 800000, .spi_clk_khz = 2000,
 };
 
@@ -188,7 +111,7 @@ static void applog_hexdump(char *prefix, uint8_t *buff, int len, int level)
 		}
 		pos += sprintf(pos, "%.2X ", buff[i]);
 	}
-	applog(LOG_DEBUG, "%s", line);
+	applog(level, "%s", line);
 }
 
 static void hexdump(char *prefix, uint8_t *buff, int len)
@@ -222,15 +145,15 @@ static uint8_t *exec_cmd(struct A1_chain *a1,
 	if (data != NULL)
 		memcpy(a1->spi_tx + 2, data, len);
 
-	bool retval = spi_transfer(a1->spi_ctx, a1->spi_tx, a1->spi_rx, tx_len);
+	assert(spi_transfer(a1->spi_ctx, a1->spi_tx, a1->spi_rx, tx_len));
 	hexdump("send: TX", a1->spi_tx, tx_len);
 	hexdump("send: RX", a1->spi_rx, tx_len);
 
 	int poll_len = resp_len;
 	if (chip_id == 0) {
 		if (a1->num_chips == 0) {
-			applog(LOG_ERR, "%d: unknown chips in chain, assuming 8",
-			       a1->board_id);
+			applog(LOG_ERR, "%d: unknown chips in chain, "
+			       "assuming 8", a1->chain_id);
 			poll_len += 32;
 		}
 		poll_len += 4 * a1->num_chips;
@@ -254,7 +177,7 @@ static uint8_t *cmd_BIST_FIX_BCAST(struct A1_chain *a1)
 {
 	uint8_t *ret = exec_cmd(a1, A1_BIST_FIX, 0x00, NULL, 0, 0);
 	if (ret == NULL || ret[0] != A1_BIST_FIX) {
-		applog(LOG_ERR, "%d: cmd_BIST_FIX_BCAST failed", a1->board_id);
+		applog(LOG_ERR, "%d: cmd_BIST_FIX_BCAST failed", a1->chain_id);
 		return NULL;
 	}
 	return ret;
@@ -267,7 +190,7 @@ static uint8_t *cmd_RESET_BCAST(struct A1_chain *a1, uint8_t strategy)
 	s[1] = strategy;
 	uint8_t *ret = exec_cmd(a1, A1_RESET, 0x00, s, 2, 0);
 	if (ret == NULL || (ret[0] != A1_RESET && a1->num_chips != 0)) {
-		applog(LOG_ERR, "%d: cmd_RESET_BCAST failed", a1->board_id);
+		applog(LOG_ERR, "%d: cmd_RESET_BCAST failed", a1->chain_id);
 		return NULL;
 	}
 	return ret;
@@ -279,22 +202,21 @@ static uint8_t *cmd_READ_RESULT_BCAST(struct A1_chain *a1)
 	memset(a1->spi_tx, 0, tx_len);
 	a1->spi_tx[0] = A1_READ_RESULT;
 
-	bool retval = spi_transfer(a1->spi_ctx, a1->spi_tx, a1->spi_rx, tx_len);
+	assert(spi_transfer(a1->spi_ctx, a1->spi_tx, a1->spi_rx, tx_len));
 	hexdump("send: TX", a1->spi_tx, tx_len);
 	hexdump("send: RX", a1->spi_rx, tx_len);
 
 	int poll_len = tx_len + 4 * a1->num_chips;
-	retval = spi_transfer(a1->spi_ctx, NULL, a1->spi_rx + tx_len, poll_len);
+	assert(spi_transfer(a1->spi_ctx, NULL, a1->spi_rx + tx_len, poll_len));
 	hexdump("poll: RX", a1->spi_rx + tx_len, poll_len);
 
 	uint8_t *scan = a1->spi_rx;
 	int i;
 	for (i = 0; i < poll_len; i += 2) {
-		if ((scan[i] & 0x0f) == A1_READ_RESULT) {
+		if ((scan[i] & 0x0f) == A1_READ_RESULT)
 			return scan + i;
-		}
 	}
-	applog(LOG_ERR, "%d: cmd_READ_RESULT_BCAST failed", a1->board_id);
+	applog(LOG_ERR, "%d: cmd_READ_RESULT_BCAST failed", a1->chain_id);
 	return NULL;
 }
 
@@ -302,7 +224,7 @@ static uint8_t *cmd_WRITE_REG(struct A1_chain *a1, uint8_t chip, uint8_t *reg)
 {
 	uint8_t *ret = exec_cmd(a1, A1_WRITE_REG, chip, reg, 6, 0);
 	if (ret == NULL || ret[0] != A1_WRITE_REG) {
-		applog(LOG_ERR, "%d: cmd_WRITE_REG failed", a1->board_id);
+		applog(LOG_ERR, "%d: cmd_WRITE_REG failed", a1->chain_id);
 		return NULL;
 	}
 	return ret;
@@ -313,7 +235,7 @@ static uint8_t *cmd_READ_REG(struct A1_chain *a1, uint8_t chip)
 	uint8_t *ret = exec_cmd(a1, A1_READ_REG, chip, NULL, 0, 6);
 	if (ret == NULL || ret[0] != A1_READ_REG_RESP || ret[1] != chip) {
 		applog(LOG_ERR, "%d: cmd_READ_REG chip %d failed",
-		       a1->board_id, chip);
+		       a1->chain_id, chip);
 		return NULL;
 	}
 	memcpy(a1->spi_rx, ret, 8);
@@ -323,20 +245,18 @@ static uint8_t *cmd_READ_REG(struct A1_chain *a1, uint8_t chip)
 static uint8_t *cmd_WRITE_JOB(struct A1_chain *a1, uint8_t chip_id,
 			      uint8_t *job)
 {
-
-	uint8_t cmd = (a1->spi_tx[0] << 8) | a1->spi_tx[1];
 	/* ensure we push the SPI command to the last chip in chain */
 	int tx_len = WRITE_JOB_LENGTH + 2;
 	memcpy(a1->spi_tx, job, WRITE_JOB_LENGTH);
 	memset(a1->spi_tx + WRITE_JOB_LENGTH, 0, tx_len - WRITE_JOB_LENGTH);
 
-	bool retval = spi_transfer(a1->spi_ctx, a1->spi_tx, a1->spi_rx, tx_len);
+	assert(spi_transfer(a1->spi_ctx, a1->spi_tx, a1->spi_rx, tx_len));
 	hexdump("send: TX", a1->spi_tx, tx_len);
 	hexdump("send: RX", a1->spi_rx, tx_len);
 
 	int poll_len = 4 * chip_id - 2;
 
-	retval = spi_transfer(a1->spi_ctx, NULL, a1->spi_rx + tx_len, poll_len);
+	assert(spi_transfer(a1->spi_ctx, NULL, a1->spi_rx + tx_len, poll_len));
 	hexdump("poll: RX", a1->spi_rx + tx_len, poll_len);
 
 	int ack_len = tx_len;
@@ -346,7 +266,7 @@ static uint8_t *cmd_WRITE_JOB(struct A1_chain *a1, uint8_t chip_id,
 	uint8_t *ret = a1->spi_rx + ack_pos;
 	if (ret[0] != a1->spi_tx[0] || ret[1] != a1->spi_tx[1]){
 		applog(LOG_ERR, "%d: cmd_WRITE_JOB failed: "
-			"0x%02x%02x/0x%02x%02x", a1->board_id,
+			"0x%02x%02x/0x%02x%02x", a1->chain_id,
 			ret[0], ret[1], a1->spi_tx[0], a1->spi_tx[1]);
 		return NULL;
 	}
@@ -354,25 +274,6 @@ static uint8_t *cmd_WRITE_JOB(struct A1_chain *a1, uint8_t chip_id,
 }
 
 /********** A1 low level functions */
-static bool A1_hw_reset(void)
-{
-	/*
-	 * TODO: issue cold reset
-	 *
-	 * NOTE: suggested sequence
-	 * a) reset the RSTN pin for at least 1s
-	 * b) release the RSTN pin
-	 * c) wait at least 1s before sending the first CMD
-	 */
-	if (!a1_board_selector_init()) {
-		applog(LOG_ERR, "Failed to init board selector");
-		a1_board_selector_exit();
-		return false;
-	}
-	a1_board_selector_reset_all_boards();
-	return true;
-}
-
 #define MAX_PLL_WAIT_CYCLES 25
 #define PLL_CYCLE_WAIT_TIME 40
 static bool check_chip_pll_lock(struct A1_chain *a1, int chip_id, uint8_t *wr)
@@ -386,7 +287,7 @@ static bool check_chip_pll_lock(struct A1_chain *a1, int chip_id, uint8_t *wr)
 
 		cgsleep_ms(PLL_CYCLE_WAIT_TIME);
 	}
-	applog(LOG_ERR, "%d: chip %d failed PLL lock", a1->board_id, chip_id);
+	applog(LOG_ERR, "%d: chip %d failed PLL lock", a1->chain_id, chip_id);
 	return false;
 }
 
@@ -394,12 +295,7 @@ static uint8_t *get_pll_reg(struct A1_chain *a1, int ref_clock_khz,
 			    int sys_clock_khz)
 {
 	/*
-	 * TODO: this is only an initial approach with binary adjusted
-	 * dividers and thus not exploiting the whole divider range.
-	 *
-	 * If required, the algorithm can be adapted to find the PLL
-	 * parameters after:
-	 *
+	 * PLL parameters after:
 	 * sys_clk = (ref_clk * pll_fbdiv) / (pll_prediv * 2^(pll_postdiv - 1))
 	 *
 	 * with a higher pll_postdiv being desired over a higher pll_prediv
@@ -408,27 +304,49 @@ static uint8_t *get_pll_reg(struct A1_chain *a1, int ref_clock_khz,
 	static uint8_t writereg[6] = { 0x00, 0x00, 0x21, 0x84, };
 	uint8_t pre_div = 1;
 	uint8_t post_div = 1;
-	uint32_t fb_div = sys_clock_khz / ref_clock_khz;
-	int bid = a1->board_id;
+	uint32_t fb_div;
+
+	int cid = a1->chain_id;
 
 	applog(LOG_WARNING, "%d: Setting PLL: CLK_REF=%dMHz, SYS_CLK=%dMHz",
-	       bid, ref_clock_khz / 1000, sys_clock_khz / 1000);
-
-	while (fb_div > 511) {
-		if (post_div < 4)
-			post_div++;
-		else
-			pre_div <<= 1;
-		fb_div >>= 1;
+	       cid, ref_clock_khz / 1000, sys_clock_khz / 1000);
+
+	/* Euclidean search for GCD */
+	int a = ref_clock_khz;
+	int b = sys_clock_khz;
+	while (b != 0) {
+		int h = a % b;
+		a = b;
+		b = h;
 	}
+	fb_div = sys_clock_khz / a;
+	int n = ref_clock_khz / a;
+	/* approximate multiplier if not exactly matchable */
+	if (fb_div > 511) {
+		int f = fb_div / n;
+		int m = (f < 32) ? 16 : (f < 64) ? 8 :
+			(f < 128) ? 4 : (256 < 2) ? 2 : 1;
+		fb_div = m * fb_div / n;
+		n =  m;
+	}
+	/* try to maximize post divider */
+	if ((n & 3) == 0)
+		post_div = 3;
+	else if ((n & 1) == 0)
+		post_div = 2;
+	else
+		post_div = 1;
+	/* remainder goes to pre_div */
+	pre_div = n / (1 << (post_div - 1));
+	/* correct pre_div overflow */
 	if (pre_div > 31) {
-		applog(LOG_WARNING, "%d: can't set PLL parameters", bid);
-		return NULL;
+		fb_div = 31 * fb_div / pre_div;
+		pre_div = 31;
 	}
 	writereg[0] = (post_div << 6) | (pre_div << 1) | (fb_div >> 8);
 	writereg[1] = fb_div & 0xff;
-	applog(LOG_WARNING, "%d: setting PLL: pre_div=%d, post_div=%d, fb_div=%d"
-	       ": 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x", bid,
+	applog(LOG_WARNING, "%d: setting PLL: pre_div=%d, post_div=%d, "
+	       "fb_div=%d: 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x", cid,
 	       pre_div, post_div, fb_div,
 	       writereg[0], writereg[1], writereg[2],
 	       writereg[3], writereg[4], writereg[5]);
@@ -444,20 +362,15 @@ static bool set_pll_config(struct A1_chain *a1, int chip_id,
 	if (!cmd_WRITE_REG(a1, chip_id, writereg))
 		return false;
 
-	int from, to;
-	if (chip_id == 0) {
-		from = 0;
-		to = a1->num_active_chips;
-	} else {
-		from = chip_id - 1;
-		to = chip_id - 1;
-	}
+	int from = (chip_id == 0) ? 0 : chip_id - 1;
+	int to = (chip_id == 0) ? a1->num_active_chips : chip_id - 1;
+
 	int i;
 	for (i = from; i < to; i++) {
 		int cid = i + 1;
 		if (!check_chip_pll_lock(a1, chip_id, writereg)) {
 			applog(LOG_ERR, "%d: chip %d failed PLL lock",
-			       a1->board_id, cid);
+			       a1->chain_id, cid);
 			return false;
 		}
 	}
@@ -471,10 +384,10 @@ static bool set_pll_config(struct A1_chain *a1, int chip_id,
 static bool check_chip(struct A1_chain *a1, int i)
 {
 	int chip_id = i + 1;
-	int bid = a1->board_id;
+	int cid = a1->chain_id;
 	if (!cmd_READ_REG(a1, chip_id)) {
 		applog(LOG_WARNING, "%d: Failed to read register for "
-		       "chip %d -> disabling", bid, chip_id);
+		       "chip %d -> disabling", cid, chip_id);
 		a1->chips[i].num_cores = 0;
 		a1->chips[i].disabled = 1;
 		return false;;
@@ -482,12 +395,12 @@ static bool check_chip(struct A1_chain *a1, int i)
 	a1->chips[i].num_cores = a1->spi_rx[7];
 	a1->num_cores += a1->chips[i].num_cores;
 	applog(LOG_WARNING, "%d: Found chip %d with %d active cores",
-	       bid, chip_id, a1->chips[i].num_cores);
+	       cid, chip_id, a1->chips[i].num_cores);
 	if (a1->chips[i].num_cores < BROKEN_CHIP_THRESHOLD) {
 		applog(LOG_WARNING, "%d: broken chip %d with %d active "
-		       "cores (threshold = %d)", bid, chip_id,
+		       "cores (threshold = %d)", cid, chip_id,
 		       a1->chips[i].num_cores, BROKEN_CHIP_THRESHOLD);
-		set_pll_config(a1, chip_id, config_options.ref_clk_khz,
+		set_pll_config(a1, chip_id, A1_config_options.ref_clk_khz,
 				BROKEN_CHIP_SYS_CLK);
 		cmd_READ_REG(a1, chip_id);
 		hexdump_error("new.PLL", a1->spi_rx, 8);
@@ -498,9 +411,9 @@ static bool check_chip(struct A1_chain *a1, int i)
 
 	if (a1->chips[i].num_cores < WEAK_CHIP_THRESHOLD) {
 		applog(LOG_WARNING, "%d: weak chip %d with %d active "
-		       "cores (threshold = %d)", bid,
+		       "cores (threshold = %d)", cid,
 		       chip_id, a1->chips[i].num_cores, WEAK_CHIP_THRESHOLD);
-		set_pll_config(a1, chip_id, config_options.ref_clk_khz,
+		set_pll_config(a1, chip_id, A1_config_options.ref_clk_khz,
 			       WEAK_CHIP_SYS_CLK);
 		cmd_READ_REG(a1, chip_id);
 		hexdump_error("new.PLL", a1->spi_rx, 8);
@@ -527,7 +440,7 @@ static int chain_detect(struct A1_chain *a1)
 	hexdump("RX", a1->spi_rx, 6);
 
 	int i;
-	int bid = a1->board_id;
+	int cid = a1->chain_id;
 	int max_poll_words = MAX_CHAIN_LENGTH * 2;
 	for(i = 1; i < max_poll_words; i++) {
 		if (a1->spi_rx[0] == A1_BIST_START && a1->spi_rx[1] == 0) {
@@ -537,12 +450,12 @@ static int chain_detect(struct A1_chain *a1)
 			a1->num_chips = (i / 2) + 1;
 			if (a1->num_chips != n) {
 				applog(LOG_ERR, "%d: enumeration: %d <-> %d",
-				       bid, a1->num_chips, n);
+				       cid, a1->num_chips, n);
 				if (n != 0)
 					a1->num_chips = n;
 			}
 			applog(LOG_WARNING, "%d: detected %d chips",
-			       bid, a1->num_chips);
+			       cid, a1->num_chips);
 			return a1->num_chips;
 		}
 		bool s = spi_transfer(a1->spi_ctx, NULL, a1->spi_rx, 2);
@@ -550,7 +463,7 @@ static int chain_detect(struct A1_chain *a1)
 		if (!s)
 			return 0;
 	}
-	applog(LOG_WARNING, "%d: no A1 chip-chain detected", bid);
+	applog(LOG_WARNING, "%d: no A1 chip-chain detected", cid);
 	return 0;
 }
 
@@ -573,13 +486,13 @@ static void disable_chip(struct A1_chain *a1, uint8_t chip_id)
 {
 	flush_spi(a1);
 	struct A1_chip *chip = &a1->chips[chip_id - 1];
-	int bid = a1->board_id;
+	int cid = a1->chain_id;
 	if (is_chip_disabled(a1, chip_id)) {
 		applog(LOG_WARNING, "%d: chip %d already disabled",
-		       bid, chip_id);
+		       cid, chip_id);
 		return;
 	}
-	applog(LOG_WARNING, "%d: temporary disabling chip %d", bid, chip_id);
+	applog(LOG_WARNING, "%d: temporary disabling chip %d", cid, chip_id);
 	chip->cooldown_begin = get_current_ms();
 }
 
@@ -587,7 +500,7 @@ static void disable_chip(struct A1_chain *a1, uint8_t chip_id)
 void check_disabled_chips(struct A1_chain *a1)
 {
 	int i;
-	int bid = a1->board_id;
+	int cid = a1->chain_id;
 	for (i = 0; i < a1->num_active_chips; i++) {
 		int chip_id = i + 1;
 		struct A1_chip *chip = &a1->chips[i];
@@ -601,11 +514,11 @@ void check_disabled_chips(struct A1_chain *a1)
 		if (!cmd_READ_REG(a1, chip_id)) {
 			chip->fail_count++;
 			applog(LOG_WARNING, "%d: chip %d not yet working - %d",
-			       bid, chip_id, chip->fail_count);
+			       cid, chip_id, chip->fail_count);
 			if (chip->fail_count > DISABLE_CHIP_FAIL_THRESHOLD) {
 				applog(LOG_WARNING,
 				       "%d: completely disabling chip %d at %d",
-				       bid, chip_id, chip->fail_count);
+				       cid, chip_id, chip->fail_count);
 				chip->disabled = true;
 				a1->num_cores -= chip->num_cores;
 				continue;
@@ -615,7 +528,7 @@ void check_disabled_chips(struct A1_chain *a1)
 			continue;
 		}
 		applog(LOG_WARNING, "%d: chip %d is working again",
-		       bid, chip_id);
+		       cid, chip_id);
 		chip->cooldown_begin = 0;
 		chip->fail_count = 0;
 	}
@@ -672,7 +585,9 @@ static uint8_t *create_job(uint8_t chip_id, uint8_t job_id, struct work *work)
 	p1[0] = bswap_32(p2[0]);
 	p1[1] = bswap_32(p2[1]);
 	p1[2] = bswap_32(p2[2]);
+#ifdef USE_REAL_DIFF
 	p1[4] = get_diff(work->sdiff);
+#endif
 	return job;
 }
 
@@ -680,17 +595,17 @@ static uint8_t *create_job(uint8_t chip_id, uint8_t job_id, struct work *work)
 static bool set_work(struct A1_chain *a1, uint8_t chip_id, struct work *work,
 		     uint8_t queue_states)
 {
-	int bid = a1->board_id;
+	int cid = a1->chain_id;
 	struct A1_chip *chip = &a1->chips[chip_id - 1];
 	bool retval = false;
 
 	int job_id = chip->last_queued_id + 1;
 
 	applog(LOG_INFO, "%d: queuing chip %d with job_id %d, state=0x%02x",
-	       bid, chip_id, job_id, queue_states);
+	       cid, chip_id, job_id, queue_states);
 	if (job_id == (queue_states & 0x0f) || job_id == (queue_states >> 4))
 		applog(LOG_WARNING, "%d: job overlap: %d, 0x%02x",
-		       bid, job_id, queue_states);
+		       cid, job_id, queue_states);
 
 	if (chip->work[chip->last_queued_id] != NULL) {
 		work_completed(a1->cgpu, chip->work[chip->last_queued_id]);
@@ -703,8 +618,8 @@ static bool set_work(struct A1_chain *a1, uint8_t chip_id, struct work *work,
 		work_completed(a1->cgpu, work);
 
 		applog(LOG_ERR, "%d: failed to set work for chip %d.%d",
-		       bid, chip_id, job_id);
-		// TODO: what else?
+		       cid, chip_id, job_id);
+		disable_chip(a1, chip_id);
 	} else {
 		chip->work[chip->last_queued_id] = work;
 		chip->last_queued_id++;
@@ -720,7 +635,7 @@ static bool get_nonce(struct A1_chain *a1, uint8_t *nonce,
 	if (ret == NULL)
 		return false;
 	if (ret[1] == 0) {
-		applog(LOG_DEBUG, "%d: output queue empty", a1->board_id);
+		applog(LOG_DEBUG, "%d: output queue empty", a1->chain_id);
 		return false;
 	}
 	*job_id = ret[0] >> 4;
@@ -743,21 +658,20 @@ void exit_A1_chain(struct A1_chain *a1)
 		return;
 	free(a1->chips);
 	a1->chips = NULL;
-	spi_exit(a1->spi_ctx);
 	a1->spi_ctx = NULL;
 	free(a1);
 }
 
-struct A1_chain *init_A1_chain(struct spi_ctx *ctx, int board_id)
+struct A1_chain *init_A1_chain(struct spi_ctx *ctx, int chain_id)
 {
 	int i;
 	struct A1_chain *a1 = malloc(sizeof(*a1));
 	assert(a1 != NULL);
 
-	applog(LOG_DEBUG, "%d: A1 init chain", a1->board_id);
+	applog(LOG_DEBUG, "%d: A1 init chain", a1->chain_id);
 	memset(a1, 0, sizeof(*a1));
 	a1->spi_ctx = ctx;
-	a1->board_id = board_id;
+	a1->chain_id = chain_id;
 
 	a1->num_chips = chain_detect(a1);
 	if (a1->num_chips == 0)
@@ -765,19 +679,19 @@ struct A1_chain *init_A1_chain(struct spi_ctx *ctx, int board_id)
 
 	applog(LOG_WARNING, "spidev%d.%d: %d: Found %d A1 chips",
 	       a1->spi_ctx->config.bus, a1->spi_ctx->config.cs_line,
-	       a1->board_id, a1->num_chips);
+	       a1->chain_id, a1->num_chips);
 
-	if (!set_pll_config(a1, 0, config_options.ref_clk_khz,
-			    config_options.sys_clk_khz))
+	if (!set_pll_config(a1, 0, A1_config_options.ref_clk_khz,
+			    A1_config_options.sys_clk_khz))
 		goto failure;
 
 	/* override max number of active chips if requested */
 	a1->num_active_chips = a1->num_chips;
-	if (config_options.override_chip_num > 0 &&
-	    a1->num_chips > config_options.override_chip_num) {
-		a1->num_active_chips = config_options.override_chip_num;
+	if (A1_config_options.override_chip_num > 0 &&
+	    a1->num_chips > A1_config_options.override_chip_num) {
+		a1->num_active_chips = A1_config_options.override_chip_num;
 		applog(LOG_WARNING, "%d: limiting chain to %d chips",
-		       a1->board_id, a1->num_active_chips);
+		       a1->chain_id, a1->num_active_chips);
 	}
 
 	a1->chips = calloc(a1->num_active_chips, sizeof(struct A1_chip));
@@ -790,7 +704,7 @@ struct A1_chain *init_A1_chain(struct spi_ctx *ctx, int board_id)
 		check_chip(a1, i);
 
 	applog(LOG_WARNING, "%d: found %d chips with total %d active cores",
-	       a1->board_id, a1->num_active_chips, a1->num_cores);
+	       a1->chain_id, a1->num_active_chips, a1->num_cores);
 
 	mutex_init(&a1->lock);
 	INIT_LIST_HEAD(&a1->active_wq.head);
@@ -802,55 +716,127 @@ failure:
 	return NULL;
 }
 
-static bool A1_detect_one_chain(struct spi_config *cfg)
+
+bool detect_coincraft_desk(void)
 {
-	struct cgpu_info *cgpu;
-	int board_id;
+	static const uint8_t mcp4x_mapping[] = { 0x2c, 0x2b, 0x2a, 0x29, 0x28 };
+	board_selector = ccd_board_selector_init();
+	if (board_selector == NULL) {
+		applog(LOG_ERR, "No CoinCrafd Desk backplane detected.");
+		return false;
+	}
+	board_selector->reset_all();
 
-	for (board_id = 0; board_id < MAX_BOARDS; board_id++) {
-		struct spi_ctx *ctx = spi_init(cfg);
+	struct spi_config cfg = default_spi_config;
+	cfg.mode = SPI_MODE_1;
+	cfg.speed = A1_config_options.spi_clk_khz * 1000;
+	struct spi_ctx *spi = spi_init(&cfg);
+	if (spi == NULL)
+		return false;
 
-		if (ctx == NULL)
-			return false;
+	int boards_detected = 0;
+	int board_id;
+	for (board_id = 0; board_id < CCD_MAX_CHAINS; board_id++) {
+		uint8_t mcp_slave = mcp4x_mapping[board_id];
+		struct mcp4x *mcp = mcp4x_init(mcp_slave);
+		if (mcp == NULL)
+			continue;
+
+		if (A1_config_options.wiper != 0)
+			mcp->set_wiper(mcp, 0, A1_config_options.wiper);
 
 		applog(LOG_WARNING, "checking board %d...", board_id);
-		a1_board_selector_select_board(board_id);
-//		a1_board_selector_reset_board();
+		board_selector->select(board_id);
+
+		struct A1_chain *a1 = init_A1_chain(spi, board_id);
+		board_selector->release();
+		if (a1 == NULL)
+			continue;
+
+		struct cgpu_info *cgpu = malloc(sizeof(*cgpu));
+		assert(cgpu != NULL);
+
+		memset(cgpu, 0, sizeof(*cgpu));
+		cgpu->drv = &bitmineA1_drv;
+		cgpu->name = "BitmineA1.CCD";
+		cgpu->threads = 1;
+
+		cgpu->device_data = a1;
+
+		a1->cgpu = cgpu;
+		a1->trimpot = mcp;
+		add_cgpu(cgpu);
+		boards_detected++;
+	}
+	if (boards_detected == 0) {
+		spi_exit(spi);
+		return false;
+	}
+	applog(LOG_WARNING, "Detected CoinCraft Desk with %d boards",
+	       boards_detected);
+	return true;
+}
+
+bool detect_coincraft_rig_v3(void)
+{
+	board_selector = ccr_board_selector_init();
+	if (board_selector == NULL)
+		return false;
+
+	struct spi_config cfg = default_spi_config;
+	cfg.mode = SPI_MODE_1;
+	cfg.speed = A1_config_options.spi_clk_khz * 1000;
+	struct spi_ctx *spi[2];
+	spi[0]= spi_init(&cfg);
+	cfg.cs_line = 1;
+	spi[1]= spi_init(&cfg);
 
-		struct A1_chain *a1 = init_A1_chain(ctx, board_id);
-		unlock_board_selector();
+	if (spi[0] == NULL || spi[1] == 0)
+		return false;
+
+
+	board_selector->reset_all();
+	int chains_detected = 0;
+	int c;
+	for (c = 0; c < CCR_MAX_CHAINS; c++) {
+		applog(LOG_WARNING, "checking RIG chain %d...", c);
+
+		board_selector->select(c);
+		struct A1_chain *a1 = init_A1_chain(spi[c & 1], c);
+		board_selector->release();
 		if (a1 == NULL)
 			continue;
 
-		cgpu = malloc(sizeof(*cgpu));
+		struct cgpu_info *cgpu = malloc(sizeof(*cgpu));
 		assert(cgpu != NULL);
 
 		memset(cgpu, 0, sizeof(*cgpu));
 		cgpu->drv = &bitmineA1_drv;
-		cgpu->name = "BitmineA1";
+		cgpu->name = "BitmineA1.CCR";
 		cgpu->threads = 1;
 
 		cgpu->device_data = a1;
 
 		a1->cgpu = cgpu;
 		add_cgpu(cgpu);
+		chains_detected++;
 	}
+	if (chains_detected == 0)
+		return false;
+
+	applog(LOG_WARNING, "Detected CoinCraft Rig with %d chains",
+	       chains_detected);
 	return true;
 }
 
-#define MAX_SPI_BUS	1
-#define MAX_SPI_CS	1
 /* Probe SPI channel and register chip chain */
 void A1_detect(bool hotplug)
 {
-	int bus;
-	int cs_line;
-	int board_id;
-
 	/* no hotplug support for now */
 	if (hotplug)
 		return;
 
+	/* parse bimine-a1-options */
 	if (opt_bitmine_a1_options != NULL && parsed_config_options == NULL) {
 		int ref_clk = 0;
 		int sys_clk = 0;
@@ -860,32 +846,26 @@ void A1_detect(bool hotplug)
 		sscanf(opt_bitmine_a1_options, "%d:%d:%d:%d",
 		       &ref_clk, &sys_clk, &spi_clk,  &override_chip_num);
 		if (ref_clk != 0)
-			config_options.ref_clk_khz = ref_clk;
+			A1_config_options.ref_clk_khz = ref_clk;
 		if (sys_clk != 0)
-			config_options.sys_clk_khz = sys_clk;
+			A1_config_options.sys_clk_khz = sys_clk;
 		if (spi_clk != 0)
-			config_options.spi_clk_khz = spi_clk;
+			A1_config_options.spi_clk_khz = spi_clk;
 		if (override_chip_num != 0)
-			config_options.override_chip_num = override_chip_num;
+			A1_config_options.override_chip_num = override_chip_num;
 
 		/* config options are global, scan them once */
-		parsed_config_options = &config_options;
+		parsed_config_options = &A1_config_options;
 	}
-
 	applog(LOG_DEBUG, "A1 detect");
-	A1_hw_reset();
-	for (bus = 0; bus < MAX_SPI_BUS; bus++) {
-		for (cs_line = 0; cs_line < MAX_SPI_CS; cs_line++) {
-			struct spi_config cfg = default_spi_config;
-			cfg.mode = SPI_MODE_1;
-			cfg.speed = config_options.spi_clk_khz * 1000;
-			cfg.bus = bus;
-			cfg.cs_line = cs_line;
-			A1_detect_one_chain(&cfg);
-		}
-	}
+	/* detect and register supported products */
+	if (detect_coincraft_desk())
+		return;
+	if (detect_coincraft_rig_v3())
+		return;
 }
 
+#define TEMP_UPDATE_INT_MS	2000
 static int64_t A1_scanwork(struct thr_info *thr)
 {
 	int i;
@@ -893,7 +873,7 @@ static int64_t A1_scanwork(struct thr_info *thr)
 	struct A1_chain *a1 = cgpu->device_data;
 	int32_t nonce_ranges_processed = 0;
 
-	a1_board_selector_select_board(a1->board_id);
+	board_selector->select(a1->chain_id);
 
 	applog(LOG_DEBUG, "A1 running scanwork");
 
@@ -904,26 +884,25 @@ static int64_t A1_scanwork(struct thr_info *thr)
 
 	mutex_lock(&a1->lock);
 
-	int bid = a1->board_id;
+	if (a1->last_temp_time + TEMP_UPDATE_INT_MS < get_current_ms()) {
+		a1->temp = board_selector->get_temp();
+		a1->last_temp_time = get_current_ms();
+	}
+	int cid = a1->chain_id;
 	/* poll queued results */
 	while (true) {
-		int res = get_nonce(a1, (uint8_t*)&nonce, &chip_id, &job_id);
-		if (res < 0) {
-			flush_spi(a1);
-			break;
-		}
-		if (res == 0)
+		if (!get_nonce(a1, (uint8_t*)&nonce, &chip_id, &job_id))
 			break;
 		nonce = bswap_32(nonce);
 		work_updated = true;
 		if (chip_id < 1 || chip_id > a1->num_active_chips) {
 			applog(LOG_WARNING, "%d: wrong chip_id %d",
-			       bid, chip_id);
+			       cid, chip_id);
 			continue;
 		}
 		if (job_id < 1 && job_id > 4) {
-			applog(LOG_WARNING, "%d: chip %d: result has wrong job_id %d",
-			       bid, chip_id, job_id);
+			applog(LOG_WARNING, "%d: chip %d: result has wrong "
+			       "job_id %d", cid, chip_id, job_id);
 			flush_spi(a1);
 			continue;
 		}
@@ -933,20 +912,20 @@ static int64_t A1_scanwork(struct thr_info *thr)
 		if (work == NULL) {
 			/* already been flushed => stale */
 			applog(LOG_WARNING, "%d: chip %d: stale nonce 0x%08x",
-			       bid, chip_id, nonce);
+			       cid, chip_id, nonce);
 			chip->stales++;
 			continue;
 		}
 		if (!submit_nonce(thr, work, nonce)) {
 			applog(LOG_WARNING, "%d: chip %d: invalid nonce 0x%08x",
-			       bid, chip_id, nonce);
+			       cid, chip_id, nonce);
 			chip->hw_errors++;
 			/* add a penalty of a full nonce range on HW errors */
 			nonce_ranges_processed--;
 			continue;
 		}
 		applog(LOG_DEBUG, "YEAH: %d: chip %d / job_id %d: nonce 0x%08x",
-		       bid, chip_id, job_id, nonce);
+		       cid, chip_id, job_id, nonce);
 		chip->nonces_found++;
 	}
 
@@ -968,7 +947,7 @@ static int64_t A1_scanwork(struct thr_info *thr)
 			continue;
 		case 2:
 			applog(LOG_ERR, "%d: chip %d: invalid state = 2",
-			       bid, c);
+			       cid, c);
 			continue;
 		case 1:
 			/* fall through */
@@ -978,7 +957,7 @@ static int64_t A1_scanwork(struct thr_info *thr)
 			work = wq_dequeue(&a1->active_wq);
 			if (work == NULL) {
 				applog(LOG_ERR, "%d: chip %d: work underflow",
-				       bid, c);
+				       cid, c);
 				break;
 			}
 			if (set_work(a1, c, work, qbuff)) {
@@ -986,7 +965,7 @@ static int64_t A1_scanwork(struct thr_info *thr)
 				nonce_ranges_processed++;
 			}
 			applog(LOG_DEBUG, "%d: chip %d: job done: %d/%d/%d/%d",
-			       bid, c,
+			       cid, c,
 			       chip->nonce_ranges_done, chip->nonces_found,
 			       chip->hw_errors, chip->stales);
 			break;
@@ -995,18 +974,18 @@ static int64_t A1_scanwork(struct thr_info *thr)
 	check_disabled_chips(a1);
 	mutex_unlock(&a1->lock);
 
-	unlock_board_selector();
+	board_selector->release();
 
 	if (nonce_ranges_processed < 0)
 		nonce_ranges_processed = 0;
 
 	if (nonce_ranges_processed != 0) {
 		applog(LOG_DEBUG, "%d, nonces processed %d",
-		       bid, nonce_ranges_processed);
+		       cid, nonce_ranges_processed);
 	}
 	/* in case of no progress, prevent busy looping */
 	if (!work_updated)
-		cgsleep_ms(160);
+		cgsleep_ms(40);
 
 	return (int64_t)nonce_ranges_processed << 32;
 }
@@ -1017,11 +996,10 @@ static bool A1_queue_full(struct cgpu_info *cgpu)
 {
 	struct A1_chain *a1 = cgpu->device_data;
 	int queue_full = false;
-	struct work *work;
 
 	mutex_lock(&a1->lock);
 	applog(LOG_DEBUG, "%d, A1 running queue_full: %d/%d",
-	       a1->board_id, a1->active_wq.num_elems, a1->num_active_chips);
+	       a1->chain_id, a1->active_wq.num_elems, a1->num_active_chips);
 
 	if (a1->active_wq.num_elems >= a1->num_active_chips * 2)
 		queue_full = true;
@@ -1036,17 +1014,17 @@ static bool A1_queue_full(struct cgpu_info *cgpu)
 static void A1_flush_work(struct cgpu_info *cgpu)
 {
 	struct A1_chain *a1 = cgpu->device_data;
-	int bid = a1->board_id;
-	a1_board_selector_select_board(bid);
+	int cid = a1->chain_id;
+	board_selector->select(cid);
 
-	applog(LOG_DEBUG, "%d: A1 running flushwork", bid);
+	applog(LOG_DEBUG, "%d: A1 running flushwork", cid);
 
 	int i;
 
 	mutex_lock(&a1->lock);
 	/* stop chips hashing current work */
 	if (!abort_work(a1)) {
-		applog(LOG_ERR, "%d: failed to abort work in chip chain!", bid);
+		applog(LOG_ERR, "%d: failed to abort work in chip chain!", cid);
 	}
 	/* flush the work chips were currently hashing */
 	for (i = 0; i < a1->num_active_chips; i++) {
@@ -1057,14 +1035,14 @@ static void A1_flush_work(struct cgpu_info *cgpu)
 			if (work == NULL)
 				continue;
 			applog(LOG_DEBUG, "%d: flushing chip %d, work %d: 0x%p",
-			       bid, i, j + 1, work);
+			       cid, i, j + 1, work);
 			work_completed(cgpu, work);
 			chip->work[j] = NULL;
 		}
 		chip->last_queued_id = 0;
 	}
 	/* flush queued work */
-	applog(LOG_DEBUG, "%d: flushing queued work...", bid);
+	applog(LOG_DEBUG, "%d: flushing queued work...", cid);
 	while (a1->active_wq.num_elems > 0) {
 		struct work *work = wq_dequeue(&a1->active_wq);
 		assert(work != NULL);
@@ -1072,14 +1050,19 @@ static void A1_flush_work(struct cgpu_info *cgpu)
 	}
 	mutex_unlock(&a1->lock);
 
-	unlock_board_selector();
+	board_selector->release();
 }
 
-static void A1_get_statline_before(char *buf, size_t len, struct cgpu_info *cgpu)
+static void A1_get_statline_before(char *buf, size_t len,
+				   struct cgpu_info *cgpu)
 {
 	struct A1_chain *a1 = cgpu->device_data;
-	tailsprintf(buf, len, " %2d:%2d/%3d ",
-		    a1->board_id, a1->num_active_chips, a1->num_cores);
+	char temp[10];
+	if (a1->temp != 0)
+		snprintf(temp, 9, "%2dC", a1->temp);
+	tailsprintf(buf, len, " %2d:%2d/%3d %s",
+		    a1->chain_id, a1->num_active_chips, a1->num_cores,
+		    a1->temp == 0 ? "   " : temp);
 }
 
 struct device_drv bitmineA1_drv = {
diff --git a/driver-avalon2.c b/driver-avalon2.c
index 5261054..4d15cf4 100644
--- a/driver-avalon2.c
+++ b/driver-avalon2.c
@@ -42,6 +42,8 @@
 #define ASSERT1(condition) __maybe_unused static char sizeof_uint32_t_must_be_4[(condition)?1:-1]
 ASSERT1(sizeof(uint32_t) == 4);
 
+#define get_fan_pwm(v)	(AVA2_PWM_MAX - (v) * AVA2_PWM_MAX / 100)
+
 int opt_avalon2_freq_min = AVA2_DEFAULT_FREQUENCY;
 int opt_avalon2_freq_max = AVA2_DEFAULT_FREQUENCY_MAX;
 
@@ -51,6 +53,11 @@ int opt_avalon2_fan_max = AVA2_DEFAULT_FAN_MAX;
 int opt_avalon2_voltage_min = AVA2_DEFAULT_VOLTAGE;
 int opt_avalon2_voltage_max = AVA2_DEFAULT_VOLTAGE_MAX;
 
+int opt_avalon2_overheat = AVALON2_TEMP_OVERHEAT;
+enum avalon2_fan_fixed opt_avalon2_fan_fixed = FAN_AUTO;
+
+static struct pool pool_stratum;
+
 static inline uint8_t rev8(uint8_t d)
 {
     int i;
@@ -77,9 +84,15 @@ char *set_avalon2_fan(char *arg)
 	if (val1 < 0 || val1 > 100 || val2 < 0 || val2 > 100 || val2 < val1)
 		return "Invalid value passed to avalon2-fan";
 
-	opt_avalon2_fan_min = AVA2_PWM_MAX - val1 * AVA2_PWM_MAX / 100;
-	opt_avalon2_fan_max = AVA2_PWM_MAX - val2 * AVA2_PWM_MAX / 100;
+	opt_avalon2_fan_min = get_fan_pwm(val1);
+	opt_avalon2_fan_max = get_fan_pwm(val2);
+
+	return NULL;
+}
 
+char *set_avalon2_fixed_speed(enum avalon2_fan_fixed *f)
+{
+	*f = FAN_FIXED;
 	return NULL;
 }
 
@@ -145,12 +158,24 @@ static int avalon2_init_pkg(struct avalon2_pkg *pkg, uint8_t type, uint8_t idx,
 
 static int job_idcmp(uint8_t *job_id, char *pool_job_id)
 {
-	int i = 0;
-	for (i = 0; i < 4; i++) {
-		if (job_id[i] != *(pool_job_id + strlen(pool_job_id) - 4 + i))
-			return 1;
-	}
-	return 0;
+	int job_id_len;
+	unsigned short crc, crc_expect;
+
+	if (!pool_job_id)
+		return 1;
+
+	job_id_len = strlen(pool_job_id);
+	crc_expect = crc16(pool_job_id, job_id_len);
+
+	crc = job_id[0] << 8 | job_id[1];
+
+	if (crc_expect == crc)
+		return 0;
+
+	applog(LOG_DEBUG, "Avalon2: job_id not match! [%04x:%04x (%s)]",
+	       crc, crc_expect, pool_job_id);
+
+	return 1;
 }
 
 static inline int get_temp_max(struct avalon2_info *info)
@@ -163,6 +188,18 @@ static inline int get_temp_max(struct avalon2_info *info)
 	return info->temp_max;
 }
 
+static inline int get_current_temp_max(struct avalon2_info *info)
+{
+	int i;
+	int t = info->temp[0];
+
+	for (i = 1; i < 2 * AVA2_DEFAULT_MODULARS; i++) {
+		if (info->temp[i] > t)
+			t = info->temp[i];
+	}
+	return t;
+}
+
 /* http://www.onsemi.com/pub_link/Collateral/ADP3208D.PDF */
 static inline uint32_t encode_voltage(uint32_t v)
 {
@@ -174,18 +211,49 @@ static inline uint32_t decode_voltage(uint32_t v)
 	return (0x78 - (rev8(v >> 8) >> 1)) * 125;
 }
 
-extern void submit_nonce2_nonce(struct thr_info *thr, uint32_t pool_no, uint32_t nonce2, uint32_t nonce);
+static void adjust_fan(struct avalon2_info *info)
+{
+	int t;
+
+	if (unlikely(info->first < 2) || opt_avalon2_fan_fixed == FAN_FIXED) {
+		info->fan_pwm = opt_avalon2_fan_min;
+		return;
+	}
+
+	t = get_current_temp_max(info);
+
+	/* TODO: Add options for temperature range and fan adjust function */
+	if (t < 50) {
+		info->fan_pwm = get_fan_pwm(40);
+		return;
+	}
+
+	if (t > 70) {
+		info->fan_pwm = get_fan_pwm(100);
+		return;
+	}
+
+	info->fan_pwm = get_fan_pwm(3 * t - 110);
+}
+
+static inline int mm_cmp_1404(struct avalon2_info *info, int modular)
+{
+	char *mm_1404 = "1404";
+	return strncmp(info->mm_version[modular] + 2, mm_1404, 4) > 0 ? 0 : 1;
+}
+
+extern void submit_nonce2_nonce(struct thr_info *thr, struct pool *pool, struct pool *real_pool, uint32_t nonce2, uint32_t nonce);
 static int decode_pkg(struct thr_info *thr, struct avalon2_ret *ar, uint8_t *pkg)
 {
 	struct cgpu_info *avalon2;
 	struct avalon2_info *info;
-	struct pool *pool;
+	struct pool *pool, *real_pool;
 
 	unsigned int expected_crc;
 	unsigned int actual_crc;
 	uint32_t nonce, nonce2, miner, modular_id;
 	int pool_no;
-	uint8_t job_id[5];
+	uint8_t job_id[4];
 	int tmp;
 
 	int type = AVA2_GETS_ERROR;
@@ -209,7 +277,7 @@ static int decode_pkg(struct thr_info *thr, struct avalon2_ret *ar, uint8_t *pkg
 
 		memcpy(&modular_id, ar->data + 28, 4);
 		modular_id = be32toh(modular_id);
-		if (modular_id == 3)
+		if (modular_id > 3)
 			modular_id = 0;
 
 		switch(type) {
@@ -219,13 +287,12 @@ static int decode_pkg(struct thr_info *thr, struct avalon2_ret *ar, uint8_t *pkg
 			memcpy(&nonce2, ar->data + 8, 4);
 			/* Calc time    ar->data + 12 */
 			memcpy(&nonce, ar->data + 16, 4);
-			memset(job_id, 0, 5);
 			memcpy(job_id, ar->data + 20, 4);
 
 			miner = be32toh(miner);
 			pool_no = be32toh(pool_no);
 			if (miner >= AVA2_DEFAULT_MINERS ||
-			    modular_id >= AVA2_DEFAULT_MINERS || 
+			    modular_id >= AVA2_DEFAULT_MINERS ||
 			    pool_no >= total_pools ||
 			    pool_no < 0) {
 				applog(LOG_DEBUG, "Avalon2: Wrong miner/pool/id no %d,%d,%d", miner, pool_no, modular_id);
@@ -236,16 +303,22 @@ static int decode_pkg(struct thr_info *thr, struct avalon2_ret *ar, uint8_t *pkg
 			nonce = be32toh(nonce);
 			nonce -= 0x180;
 
-			applog(LOG_DEBUG, "Avalon2: Found! [%s] %d:(%08x) (%08x)",
-			       job_id, pool_no, nonce2, nonce);
-			/* FIXME:
-			 * We need remember the pre_pool. then submit the stale work */
-			pool = pools[pool_no];
-			if (job_idcmp(job_id, pool->swork.job_id))
-				break;
+			applog(LOG_DEBUG, "Avalon2: Found! %d: (%08x) (%08x)",
+			       pool_no, nonce2, nonce);
+
+			real_pool = pool = pools[pool_no];
+			if (job_idcmp(job_id, pool->swork.job_id)) {
+				if (!job_idcmp(job_id, pool_stratum.swork.job_id)) {
+					applog(LOG_ERR, "Avalon2: Match to previous stratum! (%s)", pool_stratum.swork.job_id);
+					pool = &pool_stratum;
+				} else {
+					applog(LOG_ERR, "Avalon2: Cannot match to any stratum! (%s)", pool->swork.job_id);
+					break;
+				}
+			}
 
-			if (thr && !info->new_stratum)
-				submit_nonce2_nonce(thr, pool_no, nonce2, nonce);
+			if (thr && info->first)
+				submit_nonce2_nonce(thr, pool, real_pool, nonce2, nonce);
 			break;
 		case AVA2_P_STATUS:
 			memcpy(&tmp, ar->data, 4);
@@ -265,6 +338,8 @@ static int decode_pkg(struct thr_info *thr, struct avalon2_ret *ar, uint8_t *pkg
 			memcpy(&(info->power_good[modular_id]), ar->data + 24, 4);
 
 			info->get_frequency[modular_id] = be32toh(info->get_frequency[modular_id]);
+			if (info->dev_type[modular_id] == AVA2_ID_AVA3)
+				info->get_frequency[modular_id] = info->get_frequency[modular_id] * 768 / 65;
 			info->get_voltage[modular_id] = be32toh(info->get_voltage[modular_id]);
 			info->local_work[modular_id] = be32toh(info->local_work[modular_id]);
 			info->hw_work[modular_id] = be32toh(info->hw_work[modular_id]);
@@ -395,6 +470,7 @@ static int avalon2_stratum_pkgs(int fd, struct pool *pool, struct thr_info *thr)
 	int i, a, b, tmp;
 	unsigned char target[32];
 	int job_id_len;
+	unsigned short crc;
 
 	/* Send out the first stratum message STATIC */
 	applog(LOG_DEBUG, "Avalon2: Pool stratum message STATIC: %d, %d, %d, %d, %d",
@@ -429,7 +505,7 @@ static int avalon2_stratum_pkgs(int fd, struct pool *pool, struct thr_info *thr)
 	while (avalon2_send_pkg(fd, &pkg, thr) != AVA2_SEND_OK)
 		;
 
-	set_target(target, pool->swork.diff);
+	set_target(target, pool->sdiff);
 	memcpy(pkg.data, target, 32);
 	if (opt_debug) {
 		char *target_str;
@@ -447,10 +523,9 @@ static int avalon2_stratum_pkgs(int fd, struct pool *pool, struct thr_info *thr)
 	memset(pkg.data, 0, AVA2_P_DATA_LEN);
 
 	job_id_len = strlen(pool->swork.job_id);
-	job_id_len = job_id_len >= 4 ? 4 : job_id_len;
-	for (i = 0; i < job_id_len; i++) {
-		pkg.data[i] = *(pool->swork.job_id + strlen(pool->swork.job_id) - 4 + i);
-	}
+	crc = crc16(pool->swork.job_id, job_id_len);
+	pkg.data[0] = (crc & 0xff00) >> 8;
+	pkg.data[1] = crc & 0x00ff;
 	avalon2_init_pkg(&pkg, AVA2_P_JOB_ID, 1, 1);
 	while (avalon2_send_pkg(fd, &pkg, thr) != AVA2_SEND_OK)
 		;
@@ -529,7 +604,7 @@ static bool avalon2_detect_one(const char *devpath)
 	struct avalon2_info *info;
 	int ackdetect;
 	int fd;
-	int tmp, i, modular[3];
+	int tmp, i, j, modular[AVA2_DEFAULT_MODULARS];
 	char mm_version[AVA2_DEFAULT_MODULARS][16];
 
 	struct cgpu_info *avalon2;
@@ -545,25 +620,30 @@ static bool avalon2_detect_one(const char *devpath)
 	}
 	tcflush(fd, TCIOFLUSH);
 
-	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {
+	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++)
 		modular[i] = 0;
-		strcpy(mm_version[i], "NONE");
-		/* Send out detect pkg */
-		memset(detect_pkg.data, 0, AVA2_P_DATA_LEN);
-		tmp = be32toh(i);
-		memcpy(detect_pkg.data + 28, &tmp, 4);
-
-		avalon2_init_pkg(&detect_pkg, AVA2_P_DETECT, 1, 1);
-		avalon2_send_pkg(fd, &detect_pkg, NULL);
-		ackdetect = avalon2_get_result(NULL, fd, &ret_pkg);
-		applog(LOG_DEBUG, "Avalon2 Detect ID[%d]: %d", i, ackdetect);
-		if (ackdetect != AVA2_P_ACKDETECT)
-			continue;
-		modular[i] = 1;
-		memcpy(mm_version[i], ret_pkg.data, 15);
-		mm_version[i][15] = '\0';
+
+	for (j = 0; j < 2; j++) {
+		for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {
+			strcpy(mm_version[i], AVA2_MM_VERNULL);
+			/* Send out detect pkg */
+			memset(detect_pkg.data, 0, AVA2_P_DATA_LEN);
+			tmp = be32toh(i);
+			memcpy(detect_pkg.data + 28, &tmp, 4);
+
+			avalon2_init_pkg(&detect_pkg, AVA2_P_DETECT, 1, 1);
+			avalon2_send_pkg(fd, &detect_pkg, NULL);
+			ackdetect = avalon2_get_result(NULL, fd, &ret_pkg);
+			applog(LOG_DEBUG, "Avalon2 Detect ID[%d]: %d", i, ackdetect);
+			if (ackdetect != AVA2_P_ACKDETECT && modular[i] == 0)
+				continue;
+			modular[i] = 1;
+			memcpy(mm_version[i], ret_pkg.data, 15);
+			mm_version[i][15] = '\0';
+		}
 	}
-	if (!modular[0] && !modular[1] && !modular[2])
+	avalon2_close(fd);
+	if (!modular[0] && !modular[1] && !modular[2] && !modular[3])
 		return false;
 
 	/* We have a real Avalon! */
@@ -582,26 +662,27 @@ static bool avalon2_detect_one(const char *devpath)
 
 	info = avalon2->device_data;
 
-	strcpy(info->mm_version[0], mm_version[0]);
-	strcpy(info->mm_version[1], mm_version[1]);
-	strcpy(info->mm_version[2], mm_version[2]);
-
+	info->fd = -1;
 	info->baud = AVA2_IO_SPEED;
 	info->fan_pwm = AVA2_DEFAULT_FAN_PWM;
 	info->set_voltage = AVA2_DEFAULT_VOLTAGE_MIN;
 	info->set_frequency = AVA2_DEFAULT_FREQUENCY;
 	info->temp_max = 0;
-	info->temp_history_index = 0;
-	info->temp_sum = 0;
-	info->temp_old = 0;
-	info->modulars[0] = modular[0];
-	info->modulars[1] = modular[1];
-	info->modulars[2] = modular[2];	/* Enable modular */
 
-	info->fd = -1;
-	/* Set asic to idle mode after detect */
-	avalon2_close(fd);
+	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {
+		strcpy(info->mm_version[i], mm_version[i]);
+		info->modulars[i] = modular[i];	/* Enable modular */
+		info->enable[i] = modular[i];
+		info->dev_type[i] = AVA2_ID_AVAX;
+
+		if (!strncmp((char *)&(info->mm_version[i]), AVA2_FW2_PREFIXSTR, 2))
+			info->dev_type[i] = AVA2_ID_AVA2;
+		if (!strncmp((char *)&(info->mm_version[i]), AVA2_FW3_PREFIXSTR, 2))
+			info->dev_type[i] = AVA2_ID_AVA3;
+	}
 
+	pool_stratum.swork.job_id = NULL;
+	pool_stratum.merkles = 0;
 	return true;
 }
 
@@ -638,7 +719,9 @@ static bool avalon2_prepare(struct thr_info *thr)
 	if (info->fd == -1)
 		avalon2_init(avalon2);
 
-	info->first = true;
+	info->first = 0;
+
+	cglock_init(&(pool_stratum.data_lock));
 
 	return true;
 }
@@ -653,12 +736,25 @@ static int polling(struct thr_info *thr)
 	struct cgpu_info *avalon2 = thr->cgpu;
 	struct avalon2_info *info = avalon2->device_data;
 
+	static int pre_led_red[AVA2_DEFAULT_MODULARS];
 	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {
-		if (info->modulars[i]) {
+		if (info->modulars[i] && info->enable[i]) {
+			cgsleep_ms(20);
 			memset(send_pkg.data, 0, AVA2_P_DATA_LEN);
-			tmp = be32toh(i);
+
+			tmp = be32toh(info->led_red[i]); /* RED LED */
+			memcpy(send_pkg.data + 12, &tmp, 4);
+
+			tmp = be32toh(i); /* ID */
 			memcpy(send_pkg.data + 28, &tmp, 4);
-			avalon2_init_pkg(&send_pkg, AVA2_P_POLLING, 1, 1);
+			if (info->led_red[i] && mm_cmp_1404(info, i)) {
+				avalon2_init_pkg(&send_pkg, AVA2_P_TEST, 1, 1);
+				while (avalon2_send_pkg(info->fd, &send_pkg, thr) != AVA2_SEND_OK)
+					;
+				info->enable[i] = 0;
+				continue;
+			} else
+				avalon2_init_pkg(&send_pkg, AVA2_P_POLLING, 1, 1);
 
 			while (avalon2_send_pkg(info->fd, &send_pkg, thr) != AVA2_SEND_OK)
 				;
@@ -669,9 +765,58 @@ static int polling(struct thr_info *thr)
 	return 0;
 }
 
+static void copy_pool_stratum(struct pool *pool)
+{
+	int i;
+	int merkles = pool->merkles;
+	size_t coinbase_len = pool->coinbase_len;
+
+	if (!job_idcmp(pool->swork.job_id, pool_stratum.swork.job_id))
+		return;
+
+	cg_wlock(&(pool_stratum.data_lock));
+	free(pool_stratum.swork.job_id);
+	free(pool_stratum.nonce1);
+	free(pool_stratum.coinbase);
+
+	align_len(&coinbase_len);
+	pool_stratum.coinbase = calloc(coinbase_len, 1);
+	if (unlikely(!pool_stratum.coinbase))
+		quit(1, "Failed to calloc pool_stratum coinbase in avalon2");
+	memcpy(pool_stratum.coinbase, pool->coinbase, coinbase_len);
+
+
+	for (i = 0; i < pool_stratum.merkles; i++)
+		free(pool_stratum.swork.merkle_bin[i]);
+	if (merkles) {
+		pool_stratum.swork.merkle_bin = realloc(pool_stratum.swork.merkle_bin,
+						 sizeof(char *) * merkles + 1);
+		for (i = 0; i < merkles; i++) {
+			pool_stratum.swork.merkle_bin[i] = malloc(32);
+			if (unlikely(!pool_stratum.swork.merkle_bin[i]))
+				quit(1, "Failed to malloc pool_stratum swork merkle_bin");
+			memcpy(pool_stratum.swork.merkle_bin[i], pool->swork.merkle_bin[i], 32);
+		}
+	}
+
+	pool_stratum.sdiff = pool->sdiff;
+	pool_stratum.coinbase_len = pool->coinbase_len;
+	pool_stratum.nonce2_offset = pool->nonce2_offset;
+	pool_stratum.n2size = pool->n2size;
+	pool_stratum.merkles = pool->merkles;
+
+	pool_stratum.swork.job_id = strdup(pool->swork.job_id);
+	pool_stratum.nonce1 = strdup(pool->nonce1);
+
+	memcpy(pool_stratum.ntime, pool->ntime, sizeof(pool_stratum.ntime));
+	memcpy(pool_stratum.header_bin, pool->header_bin, sizeof(pool_stratum.header_bin));
+	cg_wunlock(&(pool_stratum.data_lock));
+}
+
 static int64_t avalon2_scanhash(struct thr_info *thr)
 {
 	struct avalon2_pkg send_pkg;
+	struct timeval current_stratum;
 
 	struct pool *pool;
 	struct cgpu_info *avalon2 = thr->cgpu;
@@ -681,35 +826,34 @@ static int64_t avalon2_scanhash(struct thr_info *thr)
 	uint32_t tmp, range, start;
 	int i;
 
-	if (thr->work_restart || thr->work_update ||
-	    info->first) {
-		info->new_stratum = true;
+	if (thr->work_restart || thr->work_update || !info->first) {
 		applog(LOG_DEBUG, "Avalon2: New stratum: restart: %d, update: %d, first: %d",
 		       thr->work_restart, thr->work_update, info->first);
 		thr->work_update = false;
 		thr->work_restart = false;
-		if (unlikely(info->first))
-			info->first = false;
-
 		get_work(thr, thr->id); /* Make sure pool is ready */
 
 		pool = current_pool();
 		if (!pool->has_stratum)
 			quit(1, "Avalon2: Miner Manager have to use stratum pool");
-		if (pool->coinbase_len > AVA2_P_COINBASE_SIZE)
-			quit(1, "Avalon2: Miner Manager pool coinbase length have to less then %d", AVA2_P_COINBASE_SIZE);
-		if (pool->merkles > AVA2_P_MERKLES_COUNT)
-			quit(1, "Avalon2: Miner Manager merkles have to less then %d", AVA2_P_MERKLES_COUNT);
+		if (pool->coinbase_len > AVA2_P_COINBASE_SIZE) {
+			applog(LOG_ERR, "Avalon2: Miner Manager pool coinbase length have to less then %d", AVA2_P_COINBASE_SIZE);
+			return 0;
+		}
+		if (pool->merkles > AVA2_P_MERKLES_COUNT) {
+			applog(LOG_ERR, "Avalon2: Miner Manager merkles have to less then %d", AVA2_P_MERKLES_COUNT);
+			return 0;
+		}
 
-		info->diff = (int)pool->swork.diff - 1;
+		cgtime(&info->last_stratum);
+		cg_rlock(&pool->data_lock);
 		info->pool_no = pool->pool_no;
-
-		cg_wlock(&pool->data_lock);
+		copy_pool_stratum(pool);
 		avalon2_stratum_pkgs(info->fd, pool, thr);
-		cg_wunlock(&pool->data_lock);
+		cg_runlock(&pool->data_lock);
 
 		/* Configuer the parameter from outside */
-		info->fan_pwm = opt_avalon2_fan_min;
+		adjust_fan(info);
 		info->set_voltage = opt_avalon2_voltage_min;
 		info->set_frequency = opt_avalon2_freq_min;
 
@@ -719,7 +863,12 @@ static int64_t avalon2_scanhash(struct thr_info *thr)
 		tmp = be32toh(info->fan_pwm);
 		memcpy(send_pkg.data, &tmp, 4);
 
-		tmp = encode_voltage(info->set_voltage);
+		applog(LOG_ERR, "Avalon2: Temp max: %d, Cut off temp: %d",
+		       get_current_temp_max(info), opt_avalon2_overheat);
+		if (get_current_temp_max(info) >= opt_avalon2_overheat)
+			tmp = encode_voltage(0);
+		else
+			tmp = encode_voltage(info->set_voltage);
 		tmp = be32toh(tmp);
 		memcpy(send_pkg.data + 4, &tmp, 4);
 
@@ -740,14 +889,21 @@ static int64_t avalon2_scanhash(struct thr_info *thr)
 		avalon2_init_pkg(&send_pkg, AVA2_P_SET, 1, 1);
 		while (avalon2_send_pkg(info->fd, &send_pkg, thr) != AVA2_SEND_OK)
 			;
-		info->new_stratum = false;
+
+		if (unlikely(info->first < 2))
+			info->first++;
 	}
 
+	/* Stop polling the device if there is no stratum in 3 minutes, network is down */
+	cgtime(&current_stratum);
+	if (tdiff(&current_stratum, &(info->last_stratum)) > (double)(3.0 * 60.0))
+		return 0;
+
 	polling(thr);
 
 	h = 0;
 	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {
-		h += info->local_work[i];
+		h += info->enable[i] ? (info->local_work[i] - info->hw_work[i]) : 0;
 	}
 	return h * 0xffffffff;
 }
@@ -756,26 +912,54 @@ static struct api_data *avalon2_api_stats(struct cgpu_info *cgpu)
 {
 	struct api_data *root = NULL;
 	struct avalon2_info *info = cgpu->device_data;
-	int i, a, b;
+	int i, j, a, b;
 	char buf[24];
 	double hwp;
+	int minerindex, minercount;
+
 	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {
+		if(info->dev_type[i] == AVA2_ID_AVAX)
+			continue;
 		sprintf(buf, "ID%d MM Version", i + 1);
 		root = api_add_string(root, buf, &(info->mm_version[i]), false);
 	}
-	for (i = 0; i < AVA2_DEFAULT_MINERS * AVA2_DEFAULT_MODULARS; i++) {
-		sprintf(buf, "Match work count%02d", i + 1);
-		root = api_add_int(root, buf, &(info->matching_work[i]), false);
+
+	minerindex = 0;
+	minercount = 0;
+	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {
+		if (info->dev_type[i] == AVA2_ID_AVAX) {
+			minerindex += AVA2_DEFAULT_MINERS;
+			continue;
+		}
+
+		if (info->dev_type[i] == AVA2_ID_AVA2)
+			minercount = AVA2_DEFAULT_MINERS;
+
+		if (info->dev_type[i] == AVA2_ID_AVA3)
+			minercount = AVA2_AVA3_MINERS;
+
+		for (j = minerindex; j < (minerindex + minercount); j++) {
+			sprintf(buf, "Match work count%02d", j+1);
+			root = api_add_int(root, buf, &(info->matching_work[j]), false);
+		}
+		minerindex += AVA2_DEFAULT_MINERS;
 	}
+
 	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {
+		if(info->dev_type[i] == AVA2_ID_AVAX)
+			continue;
 		sprintf(buf, "Local works%d", i + 1);
 		root = api_add_int(root, buf, &(info->local_works[i]), false);
 	}
 	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {
+		if(info->dev_type[i] == AVA2_ID_AVAX)
+			continue;
 		sprintf(buf, "Hardware error works%d", i + 1);
 		root = api_add_int(root, buf, &(info->hw_works[i]), false);
 	}
 	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {
+		if(info->dev_type[i] == AVA2_ID_AVAX)
+			continue;
 		a = info->hw_works[i];
 		b = info->local_works[i];
 		hwp = b ? ((double)a / (double)b) : 0;
@@ -784,30 +968,79 @@ static struct api_data *avalon2_api_stats(struct cgpu_info *cgpu)
 		root = api_add_percent(root, buf, &hwp, true);
 	}
 	for (i = 0; i < 2 * AVA2_DEFAULT_MODULARS; i++) {
+		if(info->dev_type[i/2] == AVA2_ID_AVAX)
+			continue;
 		sprintf(buf, "Temperature%d", i + 1);
 		root = api_add_int(root, buf, &(info->temp[i]), false);
 	}
 	for (i = 0; i < 2 * AVA2_DEFAULT_MODULARS; i++) {
+		if(info->dev_type[i/2] == AVA2_ID_AVAX)
+			continue;
 		sprintf(buf, "Fan%d", i + 1);
 		root = api_add_int(root, buf, &(info->fan[i]), false);
 	}
 	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {
+		if(info->dev_type[i] == AVA2_ID_AVAX)
+			continue;
 		sprintf(buf, "Voltage%d", i + 1);
 		root = api_add_int(root, buf, &(info->get_voltage[i]), false);
 	}
 	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {
+		if(info->dev_type[i] == AVA2_ID_AVAX)
+			continue;
 		sprintf(buf, "Frequency%d", i + 1);
 		root = api_add_int(root, buf, &(info->get_frequency[i]), false);
 	}
 	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {
+		if(info->dev_type[i] == AVA2_ID_AVAX)
+			continue;
 		sprintf(buf, "Power good %02x", i + 1);
-	root = api_add_int(root, buf, &(info->power_good[i]), false);
+		root = api_add_int(root, buf, &(info->power_good[i]), false);
 	}
 
-
 	return root;
 }
 
+static char *avalon2_set_device(struct cgpu_info *avalon2, char *option, char *setting, char *replybuf)
+{
+	int val;
+	struct avalon2_info *info;
+
+	if (strcasecmp(option, "help") == 0) {
+		sprintf(replybuf, "led: module_id");
+		return replybuf;
+	}
+
+	if (strcasecmp(option, "led") == 0) {
+		if (!setting || !*setting) {
+			sprintf(replybuf, "missing module_id setting");
+			return replybuf;
+		}
+
+		val = atoi(setting);
+		if (val < 1 || val > AVA2_DEFAULT_MODULARS) {
+			sprintf(replybuf, "invalid module_id: %d, valid range 1-%d", val, AVA2_DEFAULT_MODULARS);
+			return replybuf;
+		}
+
+		val -= 1;
+
+		info = avalon2->device_data;
+		info->led_red[val] = !info->led_red[val];
+		if (!info->led_red[val] && mm_cmp_1404(info, val)) {
+			applog(LOG_ERR, "Avalon2: MM early then MM_XX1404, enable module:%d", val + 1);
+			info->enable[val] = 1;
+		}
+
+		applog(LOG_ERR, "Avalon2: Module:%d, LED: %s", val + 1, info->led_red[val] ? "on" : "off");
+		return NULL;
+	}
+	/* TODO: Add other commands */
+
+	sprintf(replybuf, "Unknown option: %s", option);
+	return replybuf;
+}
+
 static void avalon2_shutdown(struct thr_info *thr)
 {
 	struct cgpu_info *avalon = thr->cgpu;
@@ -821,6 +1054,7 @@ struct device_drv avalon2_drv = {
 	.dname = "avalon2",
 	.name = "AV2",
 	.get_api_stats = avalon2_api_stats,
+	.set_device = avalon2_set_device,
 	.drv_detect = avalon2_detect,
 	.reinit_device = avalon2_init,
 	.thread_prepare = avalon2_prepare,
diff --git a/driver-avalon2.h b/driver-avalon2.h
index ca2e2df..bd6340d 100644
--- a/driver-avalon2.h
+++ b/driver-avalon2.h
@@ -21,22 +21,31 @@
 #define AVA2_RESET_FAULT_DECISECONDS	10
 #define AVA2_IO_SPEED		115200
 
-#define AVA2_DEFAULT_MINERS	10
-#define AVA2_DEFAULT_MODULARS	3
+#define AVA2_DEFAULT_MODULARS	4
 
 #define AVA2_PWM_MAX	0x3FF
 #define AVA2_DEFAULT_FAN_PWM	80 /* % */
 #define AVA2_DEFAULT_FAN_MIN	0
 #define AVA2_DEFAULT_FAN_MAX	100
 
-#define AVA2_DEFAULT_VOLTAGE	10000 /* V * 10000 */
+#define AVALON2_TEMP_OVERHEAT	88
+
 #define AVA2_DEFAULT_VOLTAGE_MIN	6000
 #define AVA2_DEFAULT_VOLTAGE_MAX	11000
 
-#define AVA2_DEFAULT_FREQUENCY	1500 /* In MH/s */
 #define AVA2_DEFAULT_FREQUENCY_MIN	300
 #define AVA2_DEFAULT_FREQUENCY_MAX	2000
 
+/* Avalon2 default values */
+#define AVA2_DEFAULT_MINERS	10
+#define AVA2_DEFAULT_VOLTAGE	10000 /* v * 10000 */
+#define AVA2_DEFAULT_FREQUENCY	1500 /* In MHs */
+
+/* Avalon3 default values */
+#define AVA2_AVA3_MINERS	5
+#define AVA2_AVA3_VOLTAGE	6625 /* 0.6625v */
+#define AVA2_AVA3_FREQUENCY	400  /* MHz * 11.8 = MHs: 400MHz means ~4.7GHs */
+
 /* Avalon2 protocol package type */
 #define AVA2_H1	'A'
 #define AVA2_H2	'V'
@@ -67,6 +76,21 @@
 #define AVA2_P_TEST_RET		26
 /* Avalon2 protocol package type */
 
+/* Avalon2/3 firmware prefix */
+#define AVA2_FW2_PREFIXSTR	"20"
+#define AVA2_FW3_PREFIXSTR	"33"
+
+#define AVA2_MM_VERNULL		"NONE"
+
+#define AVA2_ID_AVA2		3255
+#define AVA2_ID_AVA3		3233
+#define AVA2_ID_AVAX		3200
+
+enum avalon2_fan_fixed {
+	FAN_FIXED,
+	FAN_AUTO,
+};
+
 struct avalon2_pkg {
 	uint8_t head[2];
 	uint8_t type;
@@ -78,9 +102,19 @@ struct avalon2_pkg {
 #define avalon2_ret avalon2_pkg
 
 struct avalon2_info {
+	int first;
+	struct timeval last_stratum;
+
 	int fd;
 	int baud;
 
+	int pool_no;
+
+	int modulars[AVA2_DEFAULT_MODULARS];
+	char mm_version[AVA2_DEFAULT_MODULARS][16];
+	int dev_type[AVA2_DEFAULT_MODULARS];
+	bool enable[AVA2_DEFAULT_MODULARS];
+
 	int set_frequency;
 	int set_voltage;
 
@@ -89,30 +123,19 @@ struct avalon2_info {
 	int power_good[AVA2_DEFAULT_MODULARS];
 
 	int fan_pwm;
+	int temp_max;
 
 	int fan[2 * AVA2_DEFAULT_MODULARS];
 	int temp[2 * AVA2_DEFAULT_MODULARS];
 
-	int temp_max;
-	int temp_history_count;
-	int temp_history_index;
-	int temp_sum;
-	int temp_old;
-
-	bool first;
-	bool new_stratum;
-
-	int pool_no;
-	int diff;
-
 	int local_works[AVA2_DEFAULT_MODULARS];
 	int hw_works[AVA2_DEFAULT_MODULARS];
-	int matching_work[AVA2_DEFAULT_MINERS * AVA2_DEFAULT_MODULARS];
+
 	int local_work[AVA2_DEFAULT_MODULARS];
 	int hw_work[AVA2_DEFAULT_MODULARS];
+	int matching_work[AVA2_DEFAULT_MINERS * AVA2_DEFAULT_MODULARS];
 
-	int modulars[AVA2_DEFAULT_MODULARS];
-	char mm_version[AVA2_DEFAULT_MODULARS][16];
+	int led_red[AVA2_DEFAULT_MODULARS];
 };
 
 #define AVA2_WRITE_SIZE (sizeof(struct avalon2_pkg))
@@ -132,6 +155,8 @@ struct avalon2_info {
 extern char *set_avalon2_fan(char *arg);
 extern char *set_avalon2_freq(char *arg);
 extern char *set_avalon2_voltage(char *arg);
-
+extern char *set_avalon2_fixed_speed(enum avalon2_fan_fixed *f);
+extern enum avalon2_fan_fixed opt_avalon2_fan_fixed;
+extern int opt_avalon2_overheat;
 #endif /* USE_AVALON2 */
 #endif	/* _AVALON2_H_ */
diff --git a/driver-bitfury.c b/driver-bitfury.c
index 673e1b0..6951ccf 100644
--- a/driver-bitfury.c
+++ b/driver-bitfury.c
@@ -16,9 +16,11 @@
 #include "libbitfury.h"
 
 int opt_bxf_temp_target = BXF_TEMP_TARGET / 10;
-int opt_nf1_bits = 50;
+int opt_nfu_bits = 50;
 int opt_bxm_bits = 54;
 int opt_bxf_bits = 54;
+int opt_bxf_debug;
+int opt_osm_led_mode = 4;
 
 /* Wait longer 1/3 longer than it would take for a full nonce range */
 #define BF1WAIT 1600
@@ -132,6 +134,7 @@ static void bitfury_identify(struct cgpu_info *bitfury)
 			bf1_identify(bitfury);
 			break;
 		case IDENT_BXF:
+		case IDENT_OSM:
 		default:
 			break;
 	}
@@ -206,6 +209,13 @@ static bool bxf_send_msg(struct cgpu_info *bitfury, char *buf, enum usb_cmds cmd
 	if (unlikely(bitfury->usbinfo.nodev))
 		return false;
 
+	if (opt_bxf_debug) {
+		char *strbuf = str_text(buf);
+
+		applog(LOG_ERR, "%s %d: >BXF [%s]", bitfury->drv->name, bitfury->device_id, strbuf);
+		free(strbuf);
+	}
+
 	len = strlen(buf);
 	applog(LOG_DEBUG, "%s %d: Sending %s", bitfury->drv->name, bitfury->device_id, buf);
 	err = usb_write(bitfury, buf, len, &amount, cmd);
@@ -217,6 +227,22 @@ static bool bxf_send_msg(struct cgpu_info *bitfury, char *buf, enum usb_cmds cmd
 	return true;
 }
 
+static bool bxf_send_debugmode(struct cgpu_info *bitfury)
+{
+	char buf[16];
+
+	sprintf(buf, "debug-mode %d\n", opt_bxf_debug);
+	return bxf_send_msg(bitfury, buf, C_BXF_DEBUGMODE);
+}
+
+static bool bxf_send_ledmode(struct cgpu_info *bitfury)
+{
+	char buf[16];
+
+	sprintf(buf, "led-mode %d\n", opt_osm_led_mode);
+	return bxf_send_msg(bitfury, buf, C_BXF_LEDMODE);
+}
+
 /* Returns the amount received only if we receive a full message, otherwise
  * it returns the err value. */
 static int bxf_recv_msg(struct cgpu_info *bitfury, char *buf)
@@ -295,9 +321,9 @@ static bool bxf_detect_one(struct cgpu_info *bitfury, struct bitfury_info *info)
 	/* Sanity check and recognise variations */
 	if (info->chips <= 2 || info->chips > 999)
 		info->chips = 2;
-	else if (info->chips <= 6)
+	else if (info->chips <= 6 && info->ident == IDENT_BXF)
 		bitfury->drv->name = "HXF";
-	else if (info->chips > 6)
+	else if (info->chips > 6 && info->ident == IDENT_BXF)
 		bitfury->drv->name = "MXF";
 	info->filtered_hw = calloc(sizeof(int), info->chips);
 	info->job = calloc(sizeof(int), info->chips);
@@ -345,7 +371,7 @@ out_close:
 	return false;
 }
 
-static void nf1_close(struct cgpu_info *bitfury)
+static void nfu_close(struct cgpu_info *bitfury)
 {
 	struct bitfury_info *info = bitfury->device_data;
 	struct mcp_settings *mcp = &info->mcp;
@@ -361,18 +387,27 @@ static void nf1_close(struct cgpu_info *bitfury)
 	mcp2210_set_gpio_settings(bitfury, mcp);
 }
 
-static bool nf1_reinit(struct cgpu_info *bitfury, struct bitfury_info *info)
+static bool nfu_reinit(struct cgpu_info *bitfury, struct bitfury_info *info)
 {
-	spi_clear_buf(info);
-	spi_add_break(info);
-	spi_set_freq(info);
-	spi_send_conf(info);
-	spi_send_init(info);
-	spi_reset(bitfury, info);
-	return info->spi_txrx(bitfury, info);
+	bool ret = true;
+	int i;
+
+	for (i = 0; i < info->chips; i++) {
+		spi_clear_buf(info);
+		spi_add_break(info);
+		spi_add_fasync(info, i);
+		spi_set_freq(info);
+		spi_send_conf(info);
+		spi_send_init(info);
+		spi_reset(bitfury, info);
+		ret = info->spi_txrx(bitfury, info);
+		if (!ret)
+			break;
+	}
+	return ret;
 }
 
-static bool nf1_set_spi_settings(struct cgpu_info *bitfury, struct bitfury_info *info)
+static bool nfu_set_spi_settings(struct cgpu_info *bitfury, struct bitfury_info *info)
 {
 	struct mcp_settings *mcp = &info->mcp;
 
@@ -380,7 +415,18 @@ static bool nf1_set_spi_settings(struct cgpu_info *bitfury, struct bitfury_info
 		mcp->acsv, mcp->cstdd, mcp->ldbtcsd, mcp->sdbd, mcp->bpst, mcp->spimode);
 }
 
-static bool nf1_detect_one(struct cgpu_info *bitfury, struct bitfury_info *info)
+static void nfu_alloc_arrays(struct bitfury_info *info)
+{
+	info->payload = calloc(sizeof(struct bitfury_payload), info->chips);
+	info->oldbuf = calloc(sizeof(unsigned int) * 17, info->chips);
+	info->job_switched = calloc(sizeof(bool), info->chips);
+	info->second_run = calloc(sizeof(bool), info->chips);
+	info->work = calloc(sizeof(struct work *), info->chips);
+	info->owork = calloc(sizeof(struct work *), info->chips);
+	info->submits = calloc(sizeof(int *), info->chips);
+}
+
+static bool nfu_detect_one(struct cgpu_info *bitfury, struct bitfury_info *info)
 {
 	struct mcp_settings *mcp = &info->mcp;
 	char buf[MCP2210_BUFFER_LENGTH];
@@ -388,6 +434,17 @@ static bool nf1_detect_one(struct cgpu_info *bitfury, struct bitfury_info *info)
 	bool ret = false;
 	int i, val;
 
+	/* Identify number of chips, and use it in device name if it can fit
+	 * into 3 chars, otherwise use generic NFU name. */
+	val = sscanf(bitfury->usbdev->prod_string, "NanoFury NF%u ", &info->chips);
+	if (val < 1)
+		info->chips = 1;
+	else if (info->chips < 10) {
+		sprintf(info->product, "NF%u", info->chips);
+		bitfury->drv->name = info->product;
+	}
+	nfu_alloc_arrays(info);
+
 	info->spi_txrx = &mcp_spi_txrx;
 	mcp2210_get_gpio_settings(bitfury, mcp);
 
@@ -400,8 +457,10 @@ static bool nf1_detect_one(struct cgpu_info *bitfury, struct bitfury_info *info)
 	}
 
 	/* Set LED and PWR pins to output and high */
-	mcp->direction.pin[NF1_PIN_LED] = mcp->direction.pin[NF1_PIN_PWR_EN] = MCP2210_GPIO_OUTPUT;
-	mcp->value.pin[NF1_PIN_LED] = mcp->value.pin[NF1_PIN_PWR_EN] = MCP2210_GPIO_PIN_HIGH;
+	mcp->direction.pin[NFU_PIN_LED] = mcp->direction.pin[NFU_PIN_PWR_EN] = MCP2210_GPIO_OUTPUT;
+	mcp->value.pin[NFU_PIN_LED] = mcp->value.pin[NFU_PIN_PWR_EN] = MCP2210_GPIO_PIN_HIGH;
+	mcp->direction.pin[NFU_PIN_PWR_EN0] = MCP2210_GPIO_OUTPUT;
+	mcp->value.pin[NFU_PIN_PWR_EN0] = MCP2210_GPIO_PIN_LOW;
 
 	mcp->direction.pin[4] = MCP2210_GPIO_OUTPUT;
 	mcp->designation.pin[4] = MCP2210_PIN_CS;
@@ -440,7 +499,7 @@ static bool nf1_detect_one(struct cgpu_info *bitfury, struct bitfury_info *info)
 	mcp->acsv = 0xffef;
 	mcp->cstdd = mcp->ldbtcsd = mcp->sdbd = mcp->spimode = 0;
 	mcp->bpst = 1;
-	if (!nf1_set_spi_settings(bitfury, info))
+	if (!nfu_set_spi_settings(bitfury, info))
 		goto out;
 
 	buf[0] = 0;
@@ -449,14 +508,14 @@ static bool nf1_detect_one(struct cgpu_info *bitfury, struct bitfury_info *info)
 		goto out;
 	/* after this command SCK_OVRRIDE should read the same as current SCK
 	 * value (which for mode 0 should be 0) */
-	if (!mcp2210_get_gpio_pinval(bitfury, NF1_PIN_SCK_OVR, &val))
+	if (!mcp2210_get_gpio_pinval(bitfury, NFU_PIN_SCK_OVR, &val))
 		goto out;
 	if (val != MCP2210_GPIO_PIN_LOW)
 		goto out;
 
 	/* switch SCK to polarity (default SCK=1 in mode 2) */
 	mcp->spimode = 2;
-	if (!nf1_set_spi_settings(bitfury, info))
+	if (!nfu_set_spi_settings(bitfury, info))
 		goto out;
 	buf[0] = 0;
 	length = 1;
@@ -464,41 +523,41 @@ static bool nf1_detect_one(struct cgpu_info *bitfury, struct bitfury_info *info)
 		goto out;
 	/* after this command SCK_OVRRIDE should read the same as current SCK
 	 * value (which for mode 2 should be 1) */
-	if (!mcp2210_get_gpio_pinval(bitfury, NF1_PIN_SCK_OVR, &val))
+	if (!mcp2210_get_gpio_pinval(bitfury, NFU_PIN_SCK_OVR, &val))
 		goto out;
 	if (val != MCP2210_GPIO_PIN_HIGH)
 		goto out;
 
 	/* switch SCK to polarity (default SCK=0 in mode 0) */
 	mcp->spimode = 0;
-	if (!nf1_set_spi_settings(bitfury, info))
+	if (!nfu_set_spi_settings(bitfury, info))
 		goto out;
 	buf[0] = 0;
 	length = 1;
 	if (!mcp2210_spi_transfer(bitfury, mcp, buf, &length))
 		goto out;
-	if (!mcp2210_get_gpio_pinval(bitfury, NF1_PIN_SCK_OVR, &val))
+	if (!mcp2210_get_gpio_pinval(bitfury, NFU_PIN_SCK_OVR, &val))
 		goto out;
 	if (val != MCP2210_GPIO_PIN_LOW)
 		goto out;
 
-	info->osc6_bits = opt_nf1_bits;
-	if (!nf1_reinit(bitfury, info))
+	info->osc6_bits = opt_nfu_bits;
+	if (!nfu_reinit(bitfury, info))
 		goto out;
 
 	ret = true;
 	if (!add_cgpu(bitfury))
-		quit(1, "Failed to add_cgpu in nf1_detect_one");
+		quit(1, "Failed to add_cgpu in nfu_detect_one");
 
 	update_usb_stats(bitfury);
 	applog(LOG_INFO, "%s %d: Successfully initialised %s",
 	       bitfury->drv->name, bitfury->device_id, bitfury->device_path);
 	spi_clear_buf(info);
 
-	info->total_nonces = 1;
+	info->total_nonces = info->chips;
 out:
 	if (!ret)
-		nf1_close(bitfury);
+		nfu_close(bitfury);
 
 	return ret;
 }
@@ -730,6 +789,10 @@ static bool bxm_detect_one(struct cgpu_info *bitfury, struct bitfury_info *info)
 	if (!ret)
 		goto out;
 	info->osc6_bits = opt_bxm_bits;
+	/* Only have 2 chip devices for now */
+	info->chips = 2;
+	nfu_alloc_arrays(info);
+
 	ret = bxm_reinit(bitfury, info);
 	if (!ret)
 		goto out;
@@ -773,10 +836,11 @@ static struct cgpu_info *bitfury_detect_one(struct libusb_device *dev, struct us
 			ret = bf1_detect_one(bitfury, info);
 			break;
 		case IDENT_BXF:
+		case IDENT_OSM:
 			ret = bxf_detect_one(bitfury, info);
 			break;
-		case IDENT_NF1:
-			ret = nf1_detect_one(bitfury, info);
+		case IDENT_NFU:
+			ret = nfu_detect_one(bitfury, info);
 			break;
 		case IDENT_BXM:
 			ret = bxm_detect_one(bitfury, info);
@@ -818,9 +882,9 @@ static void adjust_bxf_chips(struct cgpu_info *bitfury, struct bitfury_info *inf
 	recalloc(info->filtered_hw, old, new);
 	recalloc(info->job, old, new);
 	recalloc(info->submits, old, new);
-	if (info->chips == 2 && chips <= 6)
+	if (info->chips == 2 && chips <= 6 && info->ident == IDENT_BXF)
 		bitfury->drv->name = "HXF";
-	else if (info->chips <= 6 && chips > 6)
+	else if (info->chips <= 6 && chips > 6 && info->ident == IDENT_BXF)
 		bitfury->drv->name = "MXF";
 	info->chips = chips;
 }
@@ -1042,7 +1106,7 @@ static void *bxf_get_results(void *userdata)
 	bxf_update_work(bitfury, info);
 
 	while (likely(!bitfury->shutdown)) {
-		char *msg;
+		char *msg, *strbuf;
 		int err;
 
 		if (unlikely(bitfury->usbinfo.nodev))
@@ -1057,14 +1121,25 @@ static void *bxf_get_results(void *userdata)
 		if (!err)
 			continue;
 
-		PARSE_BXF_MSG(submit);
+		if (opt_bxf_debug) {
+			strbuf = str_text(buf);
+			applog(LOG_ERR, "%s %d: < [%s]",
+				bitfury->drv->name, bitfury->device_id, strbuf);
+			free(strbuf);
+		}
+
+                PARSE_BXF_MSG(submit);
 		PARSE_BXF_MSG(temp);
 		PARSE_BXF_MSG(needwork);
 		PARSE_BXF_MSG(job);
 		PARSE_BXF_MSG(hwerror);
 
-		applog(LOG_DEBUG, "%s %d: Unrecognised string %s",
-		       bitfury->drv->name, bitfury->device_id, buf);
+		if (buf[0] != '#') {
+			strbuf = str_text(buf);
+			applog(LOG_DEBUG, "%s %d: Unrecognised string %s",
+			       bitfury->drv->name, bitfury->device_id, strbuf);
+			free(strbuf);
+		}
 	}
 out:
 	return NULL;
@@ -1072,9 +1147,13 @@ out:
 
 static bool bxf_prepare(struct cgpu_info *bitfury, struct bitfury_info *info)
 {
+	bxf_send_ledmode(bitfury);
+	bxf_send_debugmode(bitfury);
+
 	mutex_init(&info->lock);
 	if (pthread_create(&info->read_thr, NULL, bxf_get_results, (void *)bitfury))
 		quit(1, "Failed to create bxf read_thr");
+
 	return bxf_send_clock(bitfury, info, opt_bxf_bits);
 }
 
@@ -1087,6 +1166,7 @@ static bool bitfury_prepare(struct thr_info *thr)
 
 	switch(info->ident) {
 		case IDENT_BXF:
+		case IDENT_OSM:
 			return bxf_prepare(bitfury, info);
 			break;
 		case IDENT_BF1:
@@ -1279,32 +1359,14 @@ static void bitfury_check_work(struct thr_info *thr, struct cgpu_info *bitfury,
 
 }
 
-static int64_t nf1_scan(struct thr_info *thr, struct cgpu_info *bitfury,
-			struct bitfury_info *info)
-{
-	int64_t ret = 0;
-
-	bitfury_check_work(thr, bitfury, info, 0);
-
-	ret = bitfury_rate(info);
-
-	if (unlikely(bitfury->usbinfo.nodev)) {
-		applog(LOG_WARNING, "%s %d: Device disappeared, disabling thread",
-		       bitfury->drv->name, bitfury->device_id);
-		ret = -1;
-	}
-
-	return ret;
-}
-
-static int64_t bxm_scan(struct thr_info *thr, struct cgpu_info *bitfury,
+static int64_t nfu_scan(struct thr_info *thr, struct cgpu_info *bitfury,
 			struct bitfury_info *info)
 {
 	int64_t ret = 0;
-	int chip_n;
+	int i;
 
-	for (chip_n = 0; chip_n < 2; chip_n++)
-		bitfury_check_work(thr, bitfury, info, chip_n);
+	for (i = 0; i < info->chips; i++)
+		bitfury_check_work(thr, bitfury, info, i);
 
 	ret = bitfury_rate(info);
 
@@ -1346,13 +1408,12 @@ static int64_t bitfury_scanwork(struct thr_info *thr)
 			ret = bf1_scan(thr, bitfury, info);
 			break;
 		case IDENT_BXF:
+		case IDENT_OSM:
 			ret = bxf_scan(bitfury, info);
 			break;
-		case IDENT_NF1:
-			ret = nf1_scan(thr, bitfury, info);
-			break;
+		case IDENT_NFU:
 		case IDENT_BXM:
-			ret = bxm_scan(thr, bitfury, info);
+			ret = nfu_scan(thr, bitfury, info);
 			break;
 		default:
 			ret = 0;
@@ -1408,6 +1469,7 @@ static void bitfury_flush_work(struct cgpu_info *bitfury)
 
 	switch(info->ident) {
 		case IDENT_BXF:
+		case IDENT_OSM:
 			bxf_send_flush(bitfury);
 			bxf_update_work(bitfury, info);
 			bxf_update_work(bitfury, info);
@@ -1423,6 +1485,7 @@ static void bitfury_update_work(struct cgpu_info *bitfury)
 
 	switch(info->ident) {
 		case IDENT_BXF:
+		case IDENT_OSM:
 			bxf_update_work(bitfury, info);
 		case IDENT_BF1:
 		default:
@@ -1477,6 +1540,20 @@ static struct api_data *bxf_api_stats(struct cgpu_info *bitfury, struct bitfury_
 	return root;
 }
 
+static struct api_data *nfu_api_stats(struct bitfury_info *info)
+{
+	struct api_data *root = NULL;
+	char buf[32];
+	int i;
+
+	root = api_add_int(root, "Chips", &info->chips, false);
+	for (i = 0; i < info->chips; i++) {
+		sprintf(buf, "Core%d submits", i);
+		root = api_add_int(root, buf, &info->submits[i], false);
+	}
+	return root;
+}
+
 static struct api_data *bitfury_api_stats(struct cgpu_info *cgpu)
 {
 	struct bitfury_info *info = cgpu->device_data;
@@ -1486,8 +1563,13 @@ static struct api_data *bitfury_api_stats(struct cgpu_info *cgpu)
 			return bf1_api_stats(info);
 			break;
 		case IDENT_BXF:
+		case IDENT_OSM:
 			return bxf_api_stats(cgpu, info);
 			break;
+		case IDENT_NFU:
+		case IDENT_BXM:
+			return nfu_api_stats(info);
+			break;
 		default:
 			break;
 	}
@@ -1500,6 +1582,7 @@ static void bitfury_get_statline_before(char *buf, size_t bufsiz, struct cgpu_in
 
 	switch(info->ident) {
 		case IDENT_BXF:
+		case IDENT_OSM:
 			tailsprintf(buf, bufsiz, "%5.1fC", cgpu->temp);
 			break;
 		default:
@@ -1543,10 +1626,11 @@ static void bitfury_shutdown(struct thr_info *thr)
 			bf1_close(bitfury);
 			break;
 		case IDENT_BXF:
+		case IDENT_OSM:
 			bxf_close(info);
 			break;
-		case IDENT_NF1:
-			nf1_close(bitfury);
+		case IDENT_NFU:
+			nfu_close(bitfury);
 			break;
 		case IDENT_BXM:
 			bxm_close(bitfury, info);
diff --git a/driver-bitfury.h b/driver-bitfury.h
index 028e17b..6cbbc0a 100644
--- a/driver-bitfury.h
+++ b/driver-bitfury.h
@@ -23,13 +23,16 @@
 #define BXF_TEMP_HYSTERESIS 30
 
 extern int opt_bxf_temp_target;
-extern int opt_nf1_bits;
+extern int opt_nfu_bits;
 extern int opt_bxm_bits;
 extern int opt_bxf_bits;
+extern int opt_bxf_debug;
+extern int opt_osm_led_mode;
 
-#define NF1_PIN_LED 0
-#define NF1_PIN_SCK_OVR 5
-#define NF1_PIN_PWR_EN 6
+#define NFU_PIN_LED 0
+#define NFU_PIN_SCK_OVR 5
+#define NFU_PIN_PWR_EN 6
+#define NFU_PIN_PWR_EN0 7
 
 #define SPIBUF_SIZE 16384
 #define BITFURY_REFRESH_DELAY 100
@@ -68,9 +71,11 @@ struct bitfury_info {
 	bool valid; /* Set on first valid data being found */
 	bool failing; /* Set when an attempted restart has been sent */
 
+	int chips;
+	char product[8];
+
 	/* BF1 specific data */
 	uint8_t version;
-	char product[8];
 	uint32_t serial;
 	struct timeval tv_start;
 
@@ -86,23 +91,24 @@ struct bitfury_info {
 	int ver_major;
 	int ver_minor;
 	int hw_rev;
-	int chips;
 	uint8_t clocks; // There are two but we set them equal
 	int *filtered_hw; // Hardware errors we're told about but are filtered
 	int *job; // Completed jobs we're told about
 	int *submits; // Submitted responses
 
-	/* NF1 specific data */
+	/* NFU specific data */
 	struct mcp_settings mcp;
 	char spibuf[SPIBUF_SIZE];
 	unsigned int spibufsz;
 	int osc6_bits;
-	struct bitfury_payload payload[2];
-	unsigned oldbuf[17 * 2];
-	bool job_switched[2];
-	bool second_run[2];
-	struct work *work[2];
-	struct work *owork[2];
+
+	/* Chip sized arrays */
+	struct bitfury_payload *payload;
+	unsigned int *oldbuf; // 17 vals per chip
+	bool *job_switched;
+	bool *second_run;
+	struct work **work;
+	struct work **owork;
 
 	bool (*spi_txrx)(struct cgpu_info *, struct bitfury_info *info);
 };
diff --git a/driver-hashfast.c b/driver-hashfast.c
index 7d154a5..8227416 100644
--- a/driver-hashfast.c
+++ b/driver-hashfast.c
@@ -762,7 +762,7 @@ static bool hfa_detect_common(struct cgpu_info *hashfast)
 
 			applog(LOG_NOTICE, "%s: Found old instance by op name %s at device %d",
 			hashfast->drv->name, info->op_name, info->old_cgpu->device_id);
-			info->resets = cinfo->resets;
+			info->resets = ++cinfo->resets;
 			info->hash_clock_rate = cinfo->hash_clock_rate;
 		} else {
 			applog(LOG_NOTICE, "%s: Found device with name %s", hashfast->drv->name,
@@ -1311,7 +1311,7 @@ static bool hfa_init(struct thr_info *thr)
 
 		applog(LOG_NOTICE, "%s: Found old instance by serial number %08x at device %d",
 		       hashfast->drv->name, info->serial_number, info->old_cgpu->device_id);
-		info->resets = cinfo->resets;
+		info->resets = ++cinfo->resets;
 		/* Set the device with the last hash_clock_rate if it's
 		 * different. */
 		if (info->hash_clock_rate != cinfo->hash_clock_rate) {
@@ -1600,8 +1600,6 @@ static void hfa_running_shutdown(struct cgpu_info *hashfast, struct hashfast_inf
 {
 	int iruntime = cgpu_runtime(hashfast);
 
-	info->resets++;
-
 	/* If the device has already disapperaed, don't drop the clock in case
 	 * it was just unplugged as opposed to a failure. */
 	if (hashfast->usbinfo.nodev)
@@ -1936,7 +1934,7 @@ struct device_drv hashfast_drv = {
 	.drv_id = DRIVER_hashfast,
 	.dname = "Hashfast",
 	.name = "HFA",
-	.max_diff = 256.0, // Limit max diff to get some nonces back regardless
+	.max_diff = 32.0, // Limit max diff to get some nonces back regardless
 	.drv_detect = hfa_detect,
 	.thread_init = hfa_init,
 	.hash_work = &hash_driver_work,
diff --git a/driver-minion.c b/driver-minion.c
index 4c12f8c..cc39908 100644
--- a/driver-minion.c
+++ b/driver-minion.c
@@ -10,6 +10,8 @@
 #include "config.h"
 #include "compat.h"
 #include "miner.h"
+#include <ctype.h>
+#include <math.h>
 
 #ifndef LINUX
 static void minion_detect(__maybe_unused bool hotplug)
@@ -37,7 +39,7 @@ static void minion_detect(__maybe_unused bool hotplug)
  * TODO: These will need adjusting for final hardware
  * Look them up and calculate them?
  */
-#define MINION_QUE_HIGH 4
+#define MINION_QUE_HIGH 42
 #define MINION_QUE_LOW 2
 
 #define MINION_FFL " - from %s %s() line %d"
@@ -131,6 +133,19 @@ static void minion_detect(__maybe_unused bool hotplug)
 // enable 'no nonce' report
 #define SYS_MISC_CTL_DEFAULT 0x04
 
+#define MINION_TEMP_40 0
+#define MINION_TEMP_60 1
+#define MINION_TEMP_80 3
+#define MINION_TEMP_100 7
+#define MINION_TEMP_OVER 15
+
+static const char *min_temp_40 = "<40";
+static const char *min_temp_60 = "40-60";
+static const char *min_temp_80 = "60-80";
+static const char *min_temp_100 = "80-100";
+static const char *min_temp_over = ">100";
+static const char *min_temp_invalid = "?";
+
 // CORE data size is DATA_SIZ
 #define MINION_CORE_ENA0_31 0x10
 #define MINION_CORE_ENA32_63 0x11
@@ -210,6 +225,31 @@ struct minion_header {
 #define MINION_CHIP_SIG_SHIFT3 (((MINION_CHIP_SIG & 0xffffff00) >>  8) & 0x00ffffff)
 #define MINION_CHIP_SIG_SHIFT4 (((MINION_CHIP_SIG & 0xffff0000) >> 16) & 0x0000ffff)
 
+#define MINION_FREQ_MIN 100
+#define MINION_FREQ_DEF 1000
+#define MINION_FREQ_MAX 1400
+#define MINION_FREQ_FACTOR 100
+#define MINION_FREQ_FACTOR_MIN 1
+#define MINION_FREQ_FACTOR_MAX 14
+
+static uint32_t minion_freq[] = {
+	0x0,
+	0x205032,	//  1 =  100Mhz
+	0x203042,	//  2 =  200Mhz
+	0x20204B,	//  3 =  300Mhz
+	0x201042,	//  4 =  400Mhz
+	0x201053,	//  5 =  500Mhz
+	0x200032,	//  6 =  600Mhz
+	0x20003A,	//  7 =  700Mhz
+	0x200042,	//  8 =  800Mhz
+	0x20004B,	//  9 =  900Mhz
+	0x200053,	// 10 = 1000Mhz
+	0x21005B,	// 11 = 1100Mhz
+	0x210064,	// 12 = 1200Mhz
+	0x21006C,	// 13 = 1300Mhz
+	0x210074	// 14 = 1400Mhz
+};
+
 #define STA_TEMP(_sta) ((uint16_t)((_sta)[3] & 0x1f))
 #define STA_CORES(_sta) ((uint16_t)((_sta)[2]))
 #define STA_FREQ(_sta) ((uint32_t)((_sta)[1]) * 0x100 + (uint32_t)((_sta)[0]))
@@ -223,6 +263,7 @@ struct minion_status {
 	uint16_t cores;
 	uint32_t freq;
 	struct timeval last;
+	bool overheat;
 };
 
 // TODO: untested/unused
@@ -252,6 +293,12 @@ struct minion_result {
 
 #define MINION_RES_DATA_SIZ sizeof(struct minion_result)
 
+/*
+ * (MINION_SPI_BUFSIZ - HSIZE()) / MINION_RES_DATA_SIZ
+ * less a little bit to round it out
+ */
+#define MINION_MAX_RES 120
+
 #define MIDSTATE_BYTES 32
 #define MERKLE7_OFFSET 64
 #define MERKLE_BYTES 12
@@ -309,6 +356,7 @@ typedef struct witem {
 	int nonces;
 	bool urgent;
 	bool stale; // if stale, don't decrement count_up when discarded
+	bool rolled;
 } WITEM;
 
 #define ALLOC_TITEMS 256
@@ -385,8 +433,9 @@ typedef struct k_list {
 #define K_RLOCK(_list) cg_rlock(_list->lock)
 #define K_RUNLOCK(_list) cg_runlock(_list->lock)
 
-// Set this to 0 to remove iostats processing
-#define DO_IO_STATS 1
+// Set this to 1 to enable iostats processing
+// N.B. it slows down mining
+#define DO_IO_STATS 0
 
 #if DO_IO_STATS
 #define IO_STAT_NOW(_tv) cgtime(_tv)
@@ -511,6 +560,7 @@ struct minion_info {
 	// TODO: need to track disabled chips - done?
 	int chips;
 	bool chip[MINION_CHIPS];
+	int init_freq[MINION_CHIPS];
 
 	uint32_t next_task_id;
 
@@ -530,6 +580,9 @@ struct minion_info {
 	uint64_t untested_nonces;
 	uint64_t tested_nonces;
 
+	uint64_t work_unrolled;
+	uint64_t work_rolled;
+
 	// Work items
 	K_LIST *wfree_list;
 	K_STORE *wwork_list;
@@ -725,7 +778,7 @@ static void k_remove(K_LIST *list, K_ITEM *item)
 	list->count--;
 }
 
-static void ready_work(struct cgpu_info *minioncgpu, struct work *work)
+static void ready_work(struct cgpu_info *minioncgpu, struct work *work, bool rolled)
 {
 	struct minion_info *minioninfo = (struct minion_info *)(minioncgpu->device_data);
 	K_ITEM *item = NULL;
@@ -739,6 +792,7 @@ static void ready_work(struct cgpu_info *minioncgpu, struct work *work)
 	memset(&(DATAW(item)->sent), 0, sizeof(DATAW(item)->sent));
 	DATAW(item)->nonces = 0;
 	DATAW(item)->urgent = false;
+	DATAW(item)->rolled = rolled;
 
 	k_add_head(minioninfo->wwork_list, item, MINION_FFL_HERE);
 
@@ -934,11 +988,6 @@ static void display_ioctl(int reply, uint32_t osiz, uint8_t *obuf, uint32_t rsiz
 
 static int _do_ioctl(struct minion_info *minioninfo, uint8_t *obuf, uint32_t osiz, uint8_t *rbuf, uint32_t rsiz, MINION_FFL_ARGS)
 {
-/*
-	// TODO: remove these 2 later and rename the z[or]buf back to [or]buf
-	//  this simply ensures the IO buffers displayed are not affected by a bug elsewhere - during dev/testing
-	uint8_t obuf[MINION_BUFSIZ], rbuf[MINION_BUFSIZ];
-*/
 
 	struct spi_ioc_transfer tran;
 	int ret;
@@ -948,12 +997,13 @@ static int _do_ioctl(struct minion_info *minioninfo, uint8_t *obuf, uint32_t osi
 #endif
 
 	if ((int)osiz > MINION_BUFSIZ)
-		quitfrom(1, file, func, line, "%s() invalid osiz %u > %d", __func__, osiz, MINION_BUFSIZ);
+		quitfrom(1, file, func, line, "%s() invalid osiz %u > %d (chip=%d reg=0x%02x)",
+				__func__, osiz, MINION_BUFSIZ, (int)(obuf[0]), obuf[1]);
 
 	if (rsiz >= osiz)
-		quitfrom(1, file, func, line, "%s() invalid rsiz %u >= osiz %u", __func__, rsiz, osiz);
+		quitfrom(1, file, func, line, "%s() invalid rsiz %u >= osiz %u (chip=%u reg=0x%02x)",
+				__func__, rsiz, osiz, (int)(obuf[0]), obuf[1]);
 
-//	memcpy(obuf, zobuf, osiz);
 	memset(&obuf[0] + osiz - rsiz, 0xff, rsiz);
 
 #if MINION_SHOW_IO
@@ -1001,7 +1051,6 @@ static int _do_ioctl(struct minion_info *minioninfo, uint8_t *obuf, uint32_t osi
 
 //	display_ioctl(ret, osiz, obuf, rsiz, rbuf);
 
-//	memcpy(zrbuf, &rbuf[0], osiz);
 	return ret;
 }
 
@@ -1067,12 +1116,13 @@ static int build_cmd(struct cgpu_info *minioncgpu, struct minion_info *minioninf
 	return reply;
 }
 
-// TODO: hard coded for now
 static void init_chip(struct cgpu_info *minioncgpu, struct minion_info *minioninfo, int chip)
 {
 	uint8_t rbuf[MINION_BUFSIZ];
 	uint8_t data[4];
 	__maybe_unused int reply;
+	int choice;
+	uint32_t freq;
 
 	// Complete chip reset
 	data[0] = 0x00;
@@ -1103,6 +1153,25 @@ static void init_chip(struct cgpu_info *minioncgpu, struct minion_info *minionin
 	reply = build_cmd(minioncgpu, minioninfo,
 			  chip, WRITE_ADDR(MINION_SYS_MISC_CTL),
 			  rbuf, 0, data);
+
+	// Set chip frequency
+	choice = minioninfo->init_freq[chip];
+	if (choice < MINION_FREQ_MIN || choice > MINION_FREQ_MAX)
+		choice = MINION_FREQ_DEF;
+	choice /= MINION_FREQ_FACTOR;
+	if (choice < MINION_FREQ_FACTOR_MIN)
+		choice = MINION_FREQ_FACTOR_MIN;
+	if (choice > MINION_FREQ_FACTOR_MAX)
+		choice = MINION_FREQ_FACTOR_MAX;
+	freq = minion_freq[choice];
+	data[0] = (uint8_t)(freq & 0xff);
+	data[1] = (uint8_t)(((freq & 0xff00) >> 8) & 0xff);
+	data[2] = (uint8_t)(((freq & 0xff0000) >> 16) & 0xff);
+	data[3] = (uint8_t)(((freq & 0xff000000) >> 24) & 0xff);
+
+	reply = build_cmd(minioncgpu, minioninfo,
+			  chip, WRITE_ADDR(MINION_SYS_FREQ_CTL),
+			  rbuf, 0, data);
 }
 
 // TODO: hard coded for now
@@ -1576,6 +1645,40 @@ static bool minion_init_gpio_interrupt(struct cgpu_info *minioncgpu, struct mini
 	return true;
 }
 
+static void minion_process_options(struct minion_info *minioninfo)
+{
+	int last_freq = MINION_FREQ_DEF;
+	char *freq, *comma, *buf;
+	int i;
+
+	if (opt_minion_freq && *opt_minion_freq) {
+		buf = freq = strdup(opt_minion_freq);
+		comma = strchr(freq, ',');
+		if (comma)
+			*(comma++) = '\0';
+
+		for (i = 0; i < MINION_CHIPS; i++) {
+			if (freq && isdigit(*freq)) {
+				last_freq = (int)(round((double)atoi(freq) / (double)MINION_FREQ_FACTOR)) * MINION_FREQ_FACTOR;
+				if (last_freq < MINION_FREQ_MIN)
+					last_freq = MINION_FREQ_MIN;
+				if (last_freq > MINION_FREQ_MAX)
+					last_freq = MINION_FREQ_MAX;
+
+				freq = comma;
+				if (comma) {
+					comma = strchr(freq, ',');
+					if (comma)
+						*(comma++) = '\0';
+				}
+			}
+			minioninfo->init_freq[i] = last_freq;
+		}
+
+		free(buf);
+	}
+}
+
 static void minion_detect(bool hotplug)
 {
 	struct cgpu_info *minioncgpu = NULL;
@@ -1607,6 +1710,11 @@ static void minion_detect(bool hotplug)
 	mutex_init(&(minioninfo->spi_lock));
 	mutex_init(&(minioninfo->sta_lock));
 
+	for (i = 0; i < MINION_CHIPS; i++)
+		minioninfo->init_freq[i] = MINION_FREQ_DEF;
+
+	minion_process_options(minioninfo);
+
 	applog(LOG_WARNING, "%s: checking for chips ...", minioncgpu->drv->dname);
 
 	minion_detect_chips(minioncgpu, minioninfo);
@@ -1668,7 +1776,7 @@ static void *minion_spi_write(void *userdata)
 {
 	struct cgpu_info *minioncgpu = (struct cgpu_info *)userdata;
 	struct minion_info *minioninfo = (struct minion_info *)(minioncgpu->device_data);
-	K_ITEM *item, *tail;
+	K_ITEM *item, *tail, *task;
 	TITEM *titem;
 
 	applog(MINION_LOG, "%s%i: SPI writing...",
@@ -1750,6 +1858,46 @@ static void *minion_spi_write(void *userdata)
 							minioninfo->chip_status[chip].cores = STA_CORES(rep);
 							minioninfo->chip_status[chip].freq = STA_FREQ(rep);
 							mutex_unlock(&(minioninfo->sta_lock));
+
+							if (minioninfo->chip_status[chip].overheat) {
+								switch (STA_TEMP(rep)) {
+									case MINION_TEMP_40:
+									case MINION_TEMP_60:
+									case MINION_TEMP_80:
+										minioninfo->chip_status[chip].overheat = false;
+										applog(LOG_WARNING, "%s%d: chip %d cooled, restarting",
+												    minioncgpu->drv->name,
+												    minioncgpu->device_id,
+												    chip);
+										break;
+									default:
+										break;
+								}
+							} else {
+								if (STA_TEMP(rep) == MINION_TEMP_OVER) {
+									applog(LOG_WARNING, "%s%d: chip %d overheated! idling",
+											    minioncgpu->drv->name,
+											    minioncgpu->device_id,
+											    chip);
+									K_WLOCK(minioninfo->tfree_list);
+									task = k_get_head(minioninfo->tfree_list, MINION_FFL_HERE);
+									DATAT(task)->chip = chip;
+									DATAT(task)->write = true;
+									DATAT(task)->address = MINION_SYS_RSTN_CTL;
+									DATAT(task)->task_id = 0; // ignored
+									DATAT(task)->wsiz = MINION_SYS_SIZ;
+									DATAT(task)->rsiz = 0;
+									DATAT(task)->wbuf[0] = SYS_RSTN_CTL_FLUSH;
+									DATAT(task)->wbuf[1] = 0;
+									DATAT(task)->wbuf[2] = 0;
+									DATAT(task)->wbuf[3] = 0;
+									DATAT(task)->urgent = true;
+									k_add_head(minioninfo->task_list, task, MINION_FFL_HERE);
+									K_WUNLOCK(minioninfo->tfree_list);
+
+									minioninfo->chip_status[chip].overheat = true;
+								}
+							}
 						}
 						break;
 					case WRITE_ADDR(MINION_QUE_0):
@@ -1863,12 +2011,19 @@ static void *minion_spi_reply(void *userdata)
 				 * (except at startup) so the answer is always valid
 				 * i.e. there could be more, but never less
 				 */
-				if (res > 0) {
+				uint8_t left = res;
+				while (left > 0) {
+					res = left;
+					if (res > MINION_MAX_RES)
+						res = MINION_MAX_RES;
+					left -= res;
 					res_task.chip = chip;
 					res_task.reply = 0;
 					res_task.rsiz = res * MINION_RES_DATA_SIZ;
 					minion_txrx(&res_task);
-					if (res_task.reply > 0) {
+					if (res_task.reply <= 0)
+						break;
+					else {
 						if (res_task.reply < (int)MINION_RES_DATA_SIZ) {
 							char *buf = bin2hex((unsigned char *)(&(res_task.rbuf[res_task.osiz - res_task.rsiz])), (int)(res_task.rsiz));
 							applog(LOG_ERR, "%s%i: Bad work reply (%s) size %d, should be at least %d",
@@ -1903,12 +2058,8 @@ static void *minion_spi_reply(void *userdata)
 									K_WUNLOCK(minioninfo->rnonce_list);
 									cgsem_post(&(minioninfo->nonce_ready));
 								} else {
-									applog(LOG_ERR, "%s%i: Invalid task_id - chip %d core %d task 0x%04x nonce 0x%08x",
-											minioncgpu->drv->name, minioncgpu->device_id,
-											DATAR(item)->chip,
-											DATAR(item)->core,
-											DATAR(item)->task_id,
-											DATAR(item)->nonce);
+									applog(LOG_ERR, "%s%i: Invalid task_id - chip %d",
+											minioncgpu->drv->name, minioncgpu->device_id, chip);
 								}
 							}
 						}
@@ -2042,7 +2193,10 @@ static void cleanup_older(struct cgpu_info *minioncgpu, int chip, K_ITEM *item,
 			applog(MINION_LOG, "%s%i: marking complete - old task 0x%04x chip %d",
 					   minioncgpu->drv->name, minioncgpu->device_id,
 					   DATAW(tail)->task_id, chip);
-			work_completed(minioncgpu, DATAW(tail)->work);
+			if (DATAW(tail)->rolled)
+				free_work(DATAW(tail)->work);
+			else
+				work_completed(minioncgpu, DATAW(tail)->work);
 			K_WLOCK(minioninfo->wchip_list[chip]);
 			k_free_head(minioninfo->wfree_list, tail, MINION_FFL_HERE);
 			tail = minioninfo->wchip_list[chip]->tail;
@@ -2055,7 +2209,10 @@ static void cleanup_older(struct cgpu_info *minioncgpu, int chip, K_ITEM *item,
 			applog(MINION_LOG, "%s%i: marking complete - old task 0x%04x chip %d",
 					   minioncgpu->drv->name, minioncgpu->device_id,
 					   DATAW(item)->task_id, chip);
-			work_completed(minioncgpu, DATAW(item)->work);
+			if (DATAW(item)->rolled)
+				free_work(DATAW(item)->work);
+			else
+				work_completed(minioncgpu, DATAW(item)->work);
 			K_WLOCK(minioninfo->wchip_list[chip]);
 			k_free_head(minioninfo->wfree_list, item, MINION_FFL_HERE);
 		}
@@ -2126,8 +2283,7 @@ static enum nonce_state oknonce(struct thr_info *thr, struct cgpu_info *minioncg
 	minioninfo->chip_bad[chip]++;
 	minioninfo->core_bad[chip][core]++;
 	inc_hw_errors(thr);
-
-applog(LOG_ERR, "%s%i: HW ERROR chip %d core %d task 0x%04x nonce 0x%08x", minioncgpu->drv->name, minioncgpu->device_id, chip, core, task_id, nonce);
+//applog(LOG_ERR, "%s%i: HW ERROR chip %d core %d task 0x%04x nonce 0x%08x", minioncgpu->drv->name, minioncgpu->device_id, chip, core, task_id, nonce);
 
 	return NONCE_BAD_NONCE;
 }
@@ -2249,7 +2405,10 @@ static void minion_flush_work(struct cgpu_info *minioncgpu)
 		// mark complete all stale unused work (oldest first)
 		prev_unused = stale_unused_work;
 		while (prev_unused) {
-			work_completed(minioncgpu, DATAW(prev_unused)->work);
+			if (DATAW(prev_unused)->rolled)
+				free_work(DATAW(prev_unused)->work);
+			else
+				work_completed(minioncgpu, DATAW(prev_unused)->work);
 			prev_unused = prev_unused->prev;
 		}
 
@@ -2264,6 +2423,44 @@ static void minion_flush_work(struct cgpu_info *minioncgpu)
 	}
 }
 
+static void sys_chip_sta(struct cgpu_info *minioncgpu, int chip)
+{
+	struct minion_info *minioninfo = (struct minion_info *)(minioncgpu->device_data);
+	struct timeval now;
+	K_ITEM *item;
+	int limit;
+
+	cgtime(&now);
+	// No lock required since 'last' is only accessed here
+	if (minioninfo->chip_status[chip].last.tv_sec == 0) {
+		memcpy(&(minioninfo->chip_status[chip].last), &now, sizeof(now));
+	} else {
+		limit = MINION_STATS_UPDATE_TIME_mS +
+			(int)(random() % MINION_STATS_UPDATE_RAND_mS);
+		if (ms_tdiff(&now, &(minioninfo->chip_status[chip].last)) > limit) {
+			memcpy(&(minioninfo->chip_status[chip].last), &now, sizeof(now));
+
+			K_WLOCK(minioninfo->tfree_list);
+			item = k_get_head(minioninfo->tfree_list, MINION_FFL_HERE);
+			K_WUNLOCK(minioninfo->tfree_list);
+
+			DATAT(item)->chip = chip;
+			DATAT(item)->write = false;
+			DATAT(item)->address = READ_ADDR(MINION_SYS_CHIP_STA);
+			DATAT(item)->task_id = 0;
+			DATAT(item)->wsiz = 0;
+			DATAT(item)->rsiz = MINION_SYS_SIZ;
+			DATAT(item)->urgent = false;
+
+			K_WLOCK(minioninfo->task_list);
+			k_add_head(minioninfo->task_list, item, MINION_FFL_HERE);
+			K_WUNLOCK(minioninfo->task_list);
+
+			cgtime(&(minioninfo->chip_status[chip].last));
+		}
+	}
+}
+
 static void new_work_task(struct cgpu_info *minioncgpu, K_ITEM *witem, int chip, bool urgent, uint8_t state)
 {
 	struct minion_info *minioninfo = (struct minion_info *)(minioncgpu->device_data);
@@ -2309,40 +2506,8 @@ static void new_work_task(struct cgpu_info *minioncgpu, K_ITEM *witem, int chip,
 		cgsem_post(&(minioninfo->task_ready));
 
 	// N.B. this will only update often enough if a chip is > ~2GH/s
-	if (!urgent) {
-		struct timeval now;
-		int limit;
-
-		cgtime(&now);
-		// No lock required since 'last' is only accessed here
-		if (minioninfo->chip_status[chip].last.tv_sec == 0) {
-			memcpy(&(minioninfo->chip_status[chip].last), &now, sizeof(now));
-		} else {
-			limit = MINION_STATS_UPDATE_TIME_mS +
-				(int)(random() % MINION_STATS_UPDATE_RAND_mS);
-			if (ms_tdiff(&now, &(minioninfo->chip_status[chip].last)) > limit) {
-				memcpy(&(minioninfo->chip_status[chip].last), &now, sizeof(now));
-
-				K_WLOCK(minioninfo->tfree_list);
-				item = k_get_head(minioninfo->tfree_list, MINION_FFL_HERE);
-				K_WUNLOCK(minioninfo->tfree_list);
-
-				DATAT(item)->chip = chip;
-				DATAT(item)->write = false;
-				DATAT(item)->address = READ_ADDR(MINION_SYS_CHIP_STA);
-				DATAT(item)->task_id = 0;
-				DATAT(item)->wsiz = 0;
-				DATAT(item)->rsiz = MINION_SYS_SIZ;
-				DATAT(item)->urgent = false;
-
-				K_WLOCK(minioninfo->task_list);
-				k_add_head(minioninfo->task_list, item, MINION_FFL_HERE);
-				K_WUNLOCK(minioninfo->task_list);
-
-				cgtime(&(minioninfo->chip_status[chip].last));
-			}
-		}
-	}
+	if (!urgent)
+		sys_chip_sta(minioncgpu, chip);
 }
 
 // TODO: stale work ...
@@ -2380,7 +2545,7 @@ static void minion_do_work(struct cgpu_info *minioncgpu)
 	 */
 	for (state = 0; state < 3; state++) {
 		for (chip = 0; chip < MINION_CHIPS; chip++) {
-			if (minioninfo->chip[chip]) {
+			if (minioninfo->chip[chip] && !minioninfo->chip_status[chip].overheat) {
 				K_RLOCK(minioninfo->wchip_list[chip]);
 				count = minioninfo->wchip_list[chip]->count_up;
 				K_RUNLOCK(minioninfo->wchip_list[chip]);
@@ -2453,7 +2618,9 @@ static void minion_do_work(struct cgpu_info *minioncgpu)
 						}
 						break;
 				}
-			}
+			} else
+				if (minioninfo->chip[chip] && minioninfo->chip_status[chip].overheat && state == 2)
+					sys_chip_sta(minioncgpu, chip);
 		}
 	}
 }
@@ -2516,9 +2683,9 @@ static void minion_shutdown(struct thr_info *thr)
 static bool minion_queue_full(struct cgpu_info *minioncgpu)
 {
 	struct minion_info *minioninfo = (struct minion_info *)(minioncgpu->device_data);
-	struct work *work;
-	int count;
-	bool ret;
+	struct work *work, *usework;
+	int count, need, roll, roll_limit;
+	bool ret, rolled;
 
 	K_RLOCK(minioninfo->wwork_list);
 	count = minioninfo->wwork_list->count;
@@ -2527,14 +2694,32 @@ static bool minion_queue_full(struct cgpu_info *minioncgpu)
 	if (count >= (MINION_QUE_HIGH * minioninfo->chips))
 		ret = true;
 	else {
+		need = (MINION_QUE_HIGH * minioninfo->chips) - count;
 		work = get_queued(minioncgpu);
-		if (work)
-			ready_work(minioncgpu, work);
-		else
+		if (work) {
+			roll_limit = work->drv_rolllimit;
+			roll = 0;
+			do {
+				if (roll == 0) {
+					usework = work;
+					minioninfo->work_unrolled++;
+					rolled = false;
+				} else {
+					usework = copy_work_noffset(work, roll);
+					minioninfo->work_rolled++;
+					rolled = true;
+				}
+				ready_work(minioncgpu, usework, rolled);
+			} while (--need > 0 && ++roll <= roll_limit);
+		} else {
 			// Avoid a hard loop when we can't get work fast enough
 			cgsleep_us(42);
+		}
 
-		ret = false;
+		if (need > 0)
+			ret = false;
+		else
+			ret = true;
 	}
 
 	return ret;
@@ -2565,6 +2750,23 @@ static int64_t minion_scanwork(__maybe_unused struct thr_info *thr)
 	return hashcount;
 }
 
+static const char *temp_str(uint16_t temp)
+{
+	switch (temp) {
+		case MINION_TEMP_40:
+			return min_temp_40;
+		case MINION_TEMP_60:
+			return min_temp_60;
+		case MINION_TEMP_80:
+			return min_temp_80;
+		case MINION_TEMP_100:
+			return min_temp_100;
+		case MINION_TEMP_OVER:
+			return min_temp_over;
+	}
+	return min_temp_invalid;
+}
+
 static void minion_get_statline_before(char *buf, size_t bufsiz, struct cgpu_info *minioncgpu)
 {
 	struct minion_info *minioninfo = (struct minion_info *)(minioncgpu->device_data);
@@ -2583,8 +2785,8 @@ static void minion_get_statline_before(char *buf, size_t bufsiz, struct cgpu_inf
 	}
 	mutex_unlock(&(minioninfo->sta_lock));
 
-	tailsprintf(buf, bufsiz, "max%3dC Ch:%2d Co:%d",
-				 (int)max_temp, minioninfo->chips, (int)cores);
+	tailsprintf(buf, bufsiz, "max%sC Ch:%2d Co:%d",
+				 temp_str(max_temp), minioninfo->chips, (int)cores);
 }
 
 #define CHIPS_PER_STAT 8
@@ -2610,9 +2812,21 @@ static struct api_data *minion_api_stats(struct cgpu_info *minioncgpu)
 
 	max_chip = 0;
 	for (chip = 0; chip < MINION_CHIPS; chip++)
-		if (minioninfo->chip[chip])
+		if (minioninfo->chip[chip]) {
 			max_chip = chip;
 
+			snprintf(buf, sizeof(buf), "Chip %d Temperature", chip);
+			root = api_add_const(root, buf, temp_str(minioninfo->chip_status[chip].temp), false);
+			snprintf(buf, sizeof(buf), "Chip %d Cores", chip);
+			root = api_add_uint16(root, buf, &(minioninfo->chip_status[chip].cores), true);
+			snprintf(buf, sizeof(buf), "Chip %d Frequency", chip);
+			root = api_add_uint32(root, buf, &(minioninfo->chip_status[chip].freq), true);
+			snprintf(buf, sizeof(buf), "Chip %d InitFreq", chip);
+			root = api_add_int(root, buf, &(minioninfo->init_freq[chip]), true);
+			snprintf(buf, sizeof(buf), "Chip %d Overheat", chip);
+			root = api_add_bool(root, buf, &(minioninfo->chip_status[chip].overheat), true);
+		}
+
 	for (i = 0; i <= max_chip; i += CHIPS_PER_STAT) {
 		to = i + CHIPS_PER_STAT - 1;
 		if (to > max_chip)
@@ -2682,6 +2896,7 @@ static struct api_data *minion_api_stats(struct cgpu_info *minioncgpu)
 	root = api_add_int(root, "RFree Count", &(minioninfo->rfree_list->count), true);
 	root = api_add_int(root, "RNonce Count", &(minioninfo->rnonce_list->count), true);
 
+#if DO_IO_STATS
 #define sta_api(_name, _iostat) \
 	do { \
 		if ((_iostat).count) { \
@@ -2725,6 +2940,10 @@ static struct api_data *minion_api_stats(struct cgpu_info *minioncgpu)
 				    minioncgpu->drv->name, minioncgpu->device_id,
 				    total_secs, buf, data);
 	}
+#endif
+
+	root = api_add_uint64(root, "Work Unrolled", &(minioninfo->work_unrolled), true);
+	root = api_add_uint64(root, "Work Rolled", &(minioninfo->work_rolled), true);
 
 	root = api_add_elapsed(root, "Elapsed", &(total_secs), true);
 
diff --git a/driver-spondoolies.c b/driver-spondoolies.c
index d3e802f..6aa66cf 100644
--- a/driver-spondoolies.c
+++ b/driver-spondoolies.c
@@ -184,7 +184,7 @@ static struct api_data *spondoolies_api_stats(struct cgpu_info *cgpu)
 	struct spond_adapter *a = cgpu->device_data;
 	struct api_data *root = NULL;
 
-	root = api_add_int(root, "Temperature rate", &a->temp_rate, false);
+	root = api_add_int(root, "ASICs total rate", &a->temp_rate, false);
 	root = api_add_int(root, "Temparature rear", &a->rear_temp, false);
 	root = api_add_int(root, "Temparature front", &a->front_temp, false);
 
@@ -223,7 +223,7 @@ static void fill_minergate_request(minergate_do_job_req* work, struct work *cg_w
 				   int ntime_offset)
 {
 	uint32_t x[64/4];
-	int wd;
+	uint64_t wd;
 
 	memset(work, 0, sizeof(minergate_do_job_req));
 	//work->
@@ -237,7 +237,7 @@ static void fill_minergate_request(minergate_do_job_req* work, struct work *cg_w
 	//work->leading_zeroes = get_leading_zeroes(cg_work->target);
 	// Is there no better way to get leading zeroes?
 	work->leading_zeroes = 30;
-	wd = (int)round(cg_work->work_difficulty);
+	wd = round(cg_work->work_difficulty);
 	while (wd) {
 		work->leading_zeroes++;
 		wd = wd >> 1;
@@ -430,6 +430,7 @@ struct device_drv spondoolies_drv = {
 	.drv_id = DRIVER_spondoolies,
 	.dname = "Spondoolies",
 	.name = "SPN",
+	.max_diff = 32.0, // Limit max diff to get some nonces back regardless
 	.drv_detect = spondoolies_detect,
 	.get_api_stats = spondoolies_api_stats,
 	.thread_prepare = spondoolies_prepare,
diff --git a/libbitfury.c b/libbitfury.c
index 1857464..78f982c 100644
--- a/libbitfury.c
+++ b/libbitfury.c
@@ -122,7 +122,7 @@ void spi_set_freq(struct bitfury_info *info)
 
 void spi_send_conf(struct bitfury_info *info)
 {
-	const int8_t nf1_counters[16] = { 64, 64, SECOND_BASE, SECOND_BASE+4, SECOND_BASE+2,
+	const int8_t nfu_counters[16] = { 64, 64, SECOND_BASE, SECOND_BASE+4, SECOND_BASE+2,
 		SECOND_BASE+2+16, SECOND_BASE, SECOND_BASE+1, (FIRST_BASE)%65, (FIRST_BASE+1)%65,
 		(FIRST_BASE+3)%65, (FIRST_BASE+3+16)%65, (FIRST_BASE+4)%65, (FIRST_BASE+4+4)%65,
 		(FIRST_BASE+3+3)%65, (FIRST_BASE+3+1+3)%65 };
@@ -136,7 +136,7 @@ void spi_send_conf(struct bitfury_info *info)
 		spi_config_reg(info, i, 0);
 	/* Program counters correctly for rounds processing, here it should
 	 * start consuming power */
-	spi_add_data(info, 0x0100, nf1_counters, 16);
+	spi_add_data(info, 0x0100, nfu_counters, 16);
 }
 
 void spi_send_init(struct bitfury_info *info)
@@ -228,9 +228,9 @@ bool spi_reset(struct cgpu_info *bitfury, struct bitfury_info *info)
 	int r;
 
 	// SCK_OVRRIDE
-	mcp->value.pin[NF1_PIN_SCK_OVR] = MCP2210_GPIO_PIN_HIGH;
-	mcp->direction.pin[NF1_PIN_SCK_OVR] = MCP2210_GPIO_OUTPUT;
-	mcp->designation.pin[NF1_PIN_SCK_OVR] = MCP2210_PIN_GPIO;
+	mcp->value.pin[NFU_PIN_SCK_OVR] = MCP2210_GPIO_PIN_HIGH;
+	mcp->direction.pin[NFU_PIN_SCK_OVR] = MCP2210_GPIO_OUTPUT;
+	mcp->designation.pin[NFU_PIN_SCK_OVR] = MCP2210_PIN_GPIO;
 	if (!mcp2210_set_gpio_settings(bitfury, mcp))
 		return false;
 
@@ -243,7 +243,7 @@ bool spi_reset(struct cgpu_info *bitfury, struct bitfury_info *info)
 	}
 
 	// Deactivate override
-	mcp->direction.pin[NF1_PIN_SCK_OVR] = MCP2210_GPIO_INPUT;
+	mcp->direction.pin[NFU_PIN_SCK_OVR] = MCP2210_GPIO_INPUT;
 	if (!mcp2210_set_gpio_settings(bitfury, mcp))
 		return false;
 
@@ -370,8 +370,10 @@ bool libbitfury_sendHashData(struct thr_info *thr, struct cgpu_info *bitfury,
 					uint32_t nonce; //possible nonce
 
 					nonce = decnonce(newbuf[i]);
-					if (bitfury_checkresults(thr, info->owork[chip_n], nonce))
+					if (bitfury_checkresults(thr, info->owork[chip_n], nonce)) {
+						info->submits[chip_n]++;
 						info->nonces++;
+					}
 				}
 			}
 			memcpy(oldbuf, newbuf, 17 * 4);
diff --git a/miner.h b/miner.h
index 276e765..ffa20ee 100644
--- a/miner.h
+++ b/miner.h
@@ -351,7 +351,6 @@ struct device_drv {
 
 	/* Highest target diff the device supports */
 	double max_diff;
-	double working_diff;
 };
 
 extern struct device_drv *copy_drv(struct device_drv*);
@@ -486,7 +485,7 @@ struct cgpu_info {
 	double temp;
 	int cutofftemp;
 
-	int diff1;
+	int64_t diff1;
 	double diff_accepted;
 	double diff_rejected;
 	int last_share_pool;
@@ -518,6 +517,11 @@ struct cgpu_info {
 	bool shutdown;
 
 	struct timeval dev_start_tv;
+
+	/* For benchmarking only */
+	int hidiff;
+	int lodiff;
+	int direction;
 };
 
 extern bool add_cgpu(struct cgpu_info*);
@@ -1009,6 +1013,9 @@ extern char *opt_bitmine_a1_options;
 extern char *opt_bitmain_options;
 extern bool opt_bitmain_hwerror;
 #endif
+#ifdef USE_MINION
+extern char *opt_minion_freq;
+#endif
 #ifdef USE_USBUTILS
 extern char *opt_usb_select;
 extern int opt_usbdump;
@@ -1110,8 +1117,8 @@ extern double total_rolling;
 extern double total_mhashes_done;
 extern unsigned int new_blocks;
 extern unsigned int found_blocks;
-extern int total_accepted, total_rejected, total_diff1;;
-extern int total_getworks, total_stale, total_discarded;
+extern int64_t total_accepted, total_rejected, total_diff1;
+extern int64_t total_getworks, total_stale, total_discarded;
 extern double total_diff_accepted, total_diff_rejected, total_diff_stale;
 extern unsigned int local_work;
 extern unsigned int total_go, total_ro;
@@ -1152,11 +1159,11 @@ struct stratum_work {
 struct pool {
 	int pool_no;
 	int prio;
-	int accepted, rejected;
+	int64_t accepted, rejected;
 	int seq_rejects;
 	int seq_getfails;
 	int solved;
-	int diff1;
+	int64_t diff1;
 	char diff[8];
 	int quota;
 	int quota_gcd;
@@ -1303,7 +1310,8 @@ struct work {
 	unsigned char	target[32];
 	unsigned char	hash[32];
 
-	unsigned char	device_target[32];
+	/* This is the diff the device is currently aiming for and must be
+	 * the minimum of work_difficulty & drv->max_diff */
 	double		device_diff;
 	uint64_t	share_diff;
 
@@ -1341,6 +1349,8 @@ struct work {
 	uint32_t	id;
 	UT_hash_handle	hh;
 
+	/* This is the diff work we're aiming to submit and should match the
+	 * work->target binary */
 	double		work_difficulty;
 
 	// Allow devices to identify work if multiple sub-devices
@@ -1430,7 +1440,11 @@ extern int curses_int(const char *query);
 extern char *curses_input(const char *query);
 extern void kill_work(void);
 extern void switch_pools(struct pool *selected);
-extern void discard_work(struct work *work);
+extern void _discard_work(struct work *work);
+#define discard_work(WORK) do { \
+	_discard_work(WORK); \
+	WORK = NULL; \
+} while (0)
 extern void remove_pool(struct pool *pool);
 extern void write_config(FILE *fcfg);
 extern void zero_bestshare(void);
@@ -1440,6 +1454,7 @@ extern bool log_curses_only(int prio, const char *datetime, const char *str);
 extern void clear_logwin(void);
 extern void logwin_update(void);
 extern bool pool_tclear(struct pool *pool, bool *var);
+extern void pool_failed(struct pool *pool);
 extern struct thread_q *tq_new(void);
 extern void tq_free(struct thread_q *tq);
 extern bool tq_push(struct thread_q *tq, void *data);
@@ -1452,7 +1467,11 @@ extern void app_restart(void);
 extern void roll_work(struct work *work);
 extern struct work *make_clone(struct work *work);
 extern void clean_work(struct work *work);
-extern void free_work(struct work *work);
+extern void _free_work(struct work *work);
+#define free_work(WORK) do { \
+	_free_work(WORK); \
+	WORK = NULL; \
+} while (0)
 extern void set_work_ntime(struct work *work, int ntime);
 extern struct work *copy_work_noffset(struct work *base_work, int noffset);
 #define copy_work(work_in) copy_work_noffset(work_in, 0)
@@ -1472,6 +1491,7 @@ enum api_data_type {
 	API_UINT32,
 	API_HEX32,
 	API_UINT64,
+	API_INT64,
 	API_DOUBLE,
 	API_ELAPSED,
 	API_BOOL,
diff --git a/miner.php b/miner.php
index 8c3bef3..6d4d210 100644
--- a/miner.php
+++ b/miner.php
@@ -1173,7 +1173,11 @@ function fmt($section, $name, $value, $when, $alldata, $cf = NULL)
 	 */
 	switch ($name)
 	{
+	case '0':
+		break;
 	case 'Last Share Time':
+		if ($section == 'total')
+			break;
 		if ($section == 'POOL')
 		{
 			if ($value == 0)
@@ -1198,12 +1202,16 @@ function fmt($section, $name, $value, $when, $alldata, $cf = NULL)
 		break;
 	case 'Last getwork':
 	case 'Last Valid Work':
+		if ($section == 'total')
+			break;
 		if ($value == 0)
 			$ret = 'Never';
 		else
 			$ret = ($value - $when) . 's';
 		break;
 	case 'Last Share Pool':
+		if ($section == 'total')
+			break;
 		if ($value == -1)
 		{
 			$ret = 'None';
@@ -1212,6 +1220,8 @@ function fmt($section, $name, $value, $when, $alldata, $cf = NULL)
 		break;
 	case 'Elapsed':
 	case 'Device Elapsed':
+		if ($section == 'total')
+			break;
 		$s = $value % 60;
 		$value -= $s;
 		$value /= 60;
@@ -1244,6 +1254,8 @@ function fmt($section, $name, $value, $when, $alldata, $cf = NULL)
 		}
 		break;
 	case 'Last Well':
+		if ($section == 'total')
+			break;
 		if ($value == '0')
 		{
 			$ret = 'Never';
@@ -1253,6 +1265,8 @@ function fmt($section, $name, $value, $when, $alldata, $cf = NULL)
 			$ret = date('H:i:s', $value);
 		break;
 	case 'Last Not Well':
+		if ($section == 'total')
+			break;
 		if ($value == '0')
 			$ret = 'Never';
 		else
@@ -1262,6 +1276,8 @@ function fmt($section, $name, $value, $when, $alldata, $cf = NULL)
 		}
 		break;
 	case 'Reason Not Well':
+		if ($section == 'total')
+			break;
 		if ($value != 'None')
 			$class = $errorclass;
 		break;
@@ -1296,6 +1312,8 @@ function fmt($section, $name, $value, $when, $alldata, $cf = NULL)
 		$ret = number_format($value, 2).'/m';
 		break;
 	case 'Temperature':
+		if ($section == 'total')
+			break;
 		$ret = $value.'&deg;C';
 		if (!isset($alldata['GPU']))
 		{
@@ -1307,10 +1325,14 @@ function fmt($section, $name, $value, $when, $alldata, $cf = NULL)
 	case 'Memory Clock':
 	case 'GPU Voltage':
 	case 'GPU Activity':
+		if ($section == 'total')
+			break;
 		if ($value == 0)
 			$class = $warnclass;
 		break;
 	case 'Fan Percent':
+		if ($section == 'total')
+			break;
 		if ($value == 0)
 			$class = $warnclass;
 		else
@@ -1323,6 +1345,8 @@ function fmt($section, $name, $value, $when, $alldata, $cf = NULL)
 		}
 		break;
 	case 'Fan Speed':
+		if ($section == 'total')
+			break;
 		if ($value == 0)
 			$class = $warnclass;
 		else
@@ -1413,25 +1437,35 @@ function fmt($section, $name, $value, $when, $alldata, $cf = NULL)
 		$ret = number_format((float)$parts[0]).$dec;
 		break;
 	case 'Status':
+		if ($section == 'total')
+			break;
 		if ($value != 'Alive')
 			$class = $errorclass;
 		break;
 	case 'Enabled':
+		if ($section == 'total')
+			break;
 		if ($value != 'Y')
 			$class = $warnclass;
 		break;
 	case 'No Device':
+		if ($section == 'total')
+			break;
 		if ($value != 'false')
 			$class = $errorclass;
 		break;
 	case 'When':
 	case 'Current Block Time':
+		if ($section == 'total')
+			break;
 		$ret = date($dfmt, $value);
 		break;
+	case 'Last Share Difficulty':
+		if ($section == 'total')
+			break;
 	case 'Difficulty Accepted':
 	case 'Difficulty Rejected':
 	case 'Difficulty Stale':
-	case 'Last Share Difficulty':
 		if ($value != '')
 			$ret = number_format((float)$value, 2);
 		break;
@@ -1439,10 +1473,14 @@ function fmt($section, $name, $value, $when, $alldata, $cf = NULL)
 	case 'Device Rejected%':
 	case 'Pool Rejected%':
 	case 'Pool Stale%':
+		if ($section == 'total')
+			break;
 		if ($value != '')
 			$ret = number_format((float)$value, 2) . '%';
 		break;
 	case 'Best Share':
+		if ($section == 'total')
+			break;
 	case 'Hardware Errors':
 		if ($value != '')
 			$ret = number_format((float)$value);
@@ -1470,6 +1508,8 @@ function fmt($section, $name, $value, $when, $alldata, $cf = NULL)
 			$ret = number_format((float)$value, 2);
 		break;
 	case 'AvShr':
+		if ($section == 'total')
+			break;
 		if ($value != '')
 			$ret = number_format((float)$value, 2);
 		if ($value == 0)
@@ -1534,14 +1574,16 @@ function showdatetime()
 #
 global $singlerigsum;
 $singlerigsum = array(
- 'devs' => array('MHS av' => 1, 'MHS 5s' => 1, 'Accepted' => 1, 'Rejected' => 1,
+ 'devs' => array('MHS av' => 1, 'MHS 5s' => 1, 'MHS 1m' => 1, 'MHS 5m' => 1,
+			'MHS 15m' => 1, 'Accepted' => 1, 'Rejected' => 1,
 			'Hardware Errors' => 1, 'Utility' => 1, 'Total MH' => 1,
-			'Diff1 Shares' => 1, 'Diff1 Work' => 1, 'Difficulty Accepted' => 1,
-			'Difficulty Rejected' => 1),
+			'Diff1 Shares' => 1, 'Diff1 Work' => 1,
+			'Difficulty Accepted' => 1, 'Difficulty Rejected' => 1),
  'pools' => array('Getworks' => 1, 'Accepted' => 1, 'Rejected' => 1, 'Discarded' => 1,
 			'Stale' => 1, 'Get Failures' => 1, 'Remote Failures' => 1,
-			'Diff1 Shares' => 1, 'Diff1 Work' => 1, 'Difficulty Accepted' => 1,
-			'Difficulty Rejected' => 1, 'Difficulty Stale' => 1),
+			'Diff1 Shares' => 1, 'Diff1 Work' => 1,
+			'Difficulty Accepted' => 1, 'Difficulty Rejected' => 1,
+			'Difficulty Stale' => 1),
  'notify' => array('*' => 1));
 #
 function showtotal($total, $when, $oldvalues)
diff --git a/usbutils.c b/usbutils.c
index a0cf1d2..3882507 100644
--- a/usbutils.c
+++ b/usbutils.c
@@ -159,13 +159,13 @@ static struct usb_intinfo bxf_ints[] = {
 	USB_EPS(0,  bxf0_epinfos)
 };
 
-static struct usb_epinfo nf1_epinfos[] = {
+static struct usb_epinfo nfu_epinfos[] = {
 	{ LIBUSB_TRANSFER_TYPE_INTERRUPT,	64,	EPI(1), 0, 0 },
 	{ LIBUSB_TRANSFER_TYPE_INTERRUPT,	64,	EPO(1), 0, 0 },
 };
 
-static struct usb_intinfo nf1_ints[] = {
-	USB_EPS(0, nf1_epinfos)
+static struct usb_intinfo nfu_ints[] = {
+	USB_EPS(0, nfu_epinfos)
 };
 
 static struct usb_epinfo bxm_epinfos[] = {
@@ -415,14 +415,27 @@ static struct usb_find_devices find_dev[] = {
 	},
 	{
 		.drv = DRIVER_bitfury,
-		.name = "NF1",
-		.ident = IDENT_NF1,
+		.name = "OSM",
+		.ident = IDENT_OSM,
+		.idVendor = 0x198c,
+		.idProduct = 0xb1f1,
+		.config = 1,
+		.timeout = BITFURY_TIMEOUT_MS,
+		.latency = LATENCY_UNUSED,
+		.iManufacturer = "c-scape",
+		.iProduct = "OneString",
+		INTINFO(bxf_ints)
+	},
+	{
+		.drv = DRIVER_bitfury,
+		.name = "NFU",
+		.ident = IDENT_NFU,
 		.idVendor = 0x04d8,
 		.idProduct = 0x00de,
 		.config = 1,
 		.timeout = BITFURY_TIMEOUT_MS,
 		.latency = LATENCY_UNUSED,
-		INTINFO(nf1_ints)
+		INTINFO(nfu_ints)
 	},
 	{
 		.drv = DRIVER_bitfury,
diff --git a/usbutils.h b/usbutils.h
index b05882e..7f51186 100644
--- a/usbutils.h
+++ b/usbutils.h
@@ -158,7 +158,8 @@ enum sub_ident {
 	IDENT_KLN,
 	IDENT_LLT,
 	IDENT_MMQ,
-	IDENT_NF1
+	IDENT_NFU,
+	IDENT_OSM
 };
 
 struct usb_find_devices {
@@ -376,6 +377,8 @@ struct cg_usb_info {
 	USB_ADD_COMMAND(C_BXF_MAXROLL, "BXFMaxRoll") \
 	USB_ADD_COMMAND(C_BXF_FLUSH, "BXFFlush") \
 	USB_ADD_COMMAND(C_BXF_CLOCK, "BXFClock") \
+	USB_ADD_COMMAND(C_BXF_LEDMODE, "BXFLedMode") \
+	USB_ADD_COMMAND(C_BXF_DEBUGMODE, "BXFDebugMode") \
 	USB_ADD_COMMAND(C_BXM_FLUSH, "BXMFlush") \
 	USB_ADD_COMMAND(C_BXM_SRESET, "BXMSReset") \
 	USB_ADD_COMMAND(C_BXM_SETLATENCY, "BXMSetLatency") \
diff --git a/util.c b/util.c
index 65692f2..1f61ac9 100644
--- a/util.c
+++ b/util.c
@@ -1685,6 +1685,27 @@ static bool parse_notify(struct pool *pool, json_t *val)
 	ntime = __json_array_string(val, 7);
 	clean = json_is_true(json_array_get(val, 8));
 
+#ifdef USE_AVALON2
+	static struct timeval tv_last;
+	struct timeval tv_now;
+
+	cgtime(&tv_now);
+	applog(LOG_DEBUG, "Stratum pool %p: Clean %d: (Now: %ld, Last: %ld) tdiff: %ld",
+	       pool, clean,
+	       (long)tv_now.tv_sec, (long)tv_last.tv_sec,
+	       (long)tdiff(&tv_now, &tv_last));
+	if (pool == current_pool()) {
+		if ((double)tdiff(&tv_now, &tv_last) < (double)30 &&
+		    clean == false) {
+			applog(LOG_ERR, "Ignore job_id: %s", job_id);
+			ret = true;
+			goto out;
+		}
+
+		tv_last.tv_sec = tv_now.tv_sec;
+		tv_last.tv_usec = tv_now.tv_usec;
+	}
+#endif
 	if (!job_id || !prev_hash || !coinbase1 || !coinbase2 || !bbversion || !nbit || !ntime) {
 		/* Annoying but we must not leak memory */
 		if (job_id)
@@ -1855,6 +1876,26 @@ static bool parse_reconnect(struct pool *pool, json_t *val)
 	url = (char *)json_string_value(json_array_get(val, 0));
 	if (!url)
 		url = pool->sockaddr_url;
+	else {
+		char *dot_pool, *dot_reconnect;
+		dot_pool = strchr(pool->sockaddr_url, '.');
+		if (!dot_pool) {
+			applog(LOG_ERR, "Denied stratum reconnect request for pool without domain '%s'",
+			       pool->sockaddr_url);
+			return false;
+		}
+		dot_reconnect = strchr(url, '.');
+		if (!dot_reconnect) {
+			applog(LOG_ERR, "Denied stratum reconnect request to url without domain '%s'",
+			       url);
+			return false;
+		}
+		if (strcmp(dot_pool, dot_reconnect)) {
+			applog(LOG_ERR, "Denied stratum reconnect request to non-matching domain url '%s'",
+				pool->sockaddr_url);
+			return false;
+		}
+	}
 
 	port = (char *)json_string_value(json_array_get(val, 1));
 	if (!port)
@@ -1865,7 +1906,7 @@ static bool parse_reconnect(struct pool *pool, json_t *val)
 	if (!extract_sockaddr(address, &sockaddr_url, &stratum_port))
 		return false;
 
-	applog(LOG_NOTICE, "Reconnect requested from pool %d to %s", pool->pool_no, address);
+	applog(LOG_WARNING, "Stratum reconnect requested from pool %d to %s", pool->pool_no, address);
 
 	clear_pool_work(pool);
 
@@ -1880,8 +1921,10 @@ static bool parse_reconnect(struct pool *pool, json_t *val)
 	free(tmp);
 	mutex_unlock(&pool->stratum_lock);
 
-	if (!restart_stratum(pool))
+	if (!restart_stratum(pool)) {
+		pool_failed(pool);
 		return false;
+	}
 
 	return true;
 }
@@ -2025,6 +2068,8 @@ bool auth_stratum(struct pool *pool)
 		applog(LOG_INFO, "pool %d JSON stratum auth failed: %s", pool->pool_no, ss);
 		free(ss);
 
+		suspend_stratum(pool);
+
 		goto out;
 	}
 
