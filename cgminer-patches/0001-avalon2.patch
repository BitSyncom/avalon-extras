[1mdiff --git a/cgminer.c b/cgminer.c[m
[1mindex c3da2de..54d2a5a 100644[m
[1m--- a/cgminer.c[m
[1m+++ b/cgminer.c[m
[36m@@ -6765,6 +6765,8 @@[m [mvoid set_target(unsigned char *dest_target, double diff)[m
 #ifdef USE_AVALON2[m
 void submit_nonce2_nonce(struct thr_info *thr, uint32_t pool_no, uint32_t nonce2, uint32_t nonce)[m
 {[m
[32m+[m	[32mconst int thr_id = thr->id;[m
[32m+[m
 	struct cgpu_info *cgpu = thr->cgpu;[m
 	struct device_drv *drv = cgpu->drv;[m
 [m
[36m@@ -6774,6 +6776,13 @@[m [mvoid submit_nonce2_nonce(struct thr_info *thr, uint32_t pool_no, uint32_t nonce2[m
 	pool->nonce2 = nonce2;[m
 	gen_stratum_work(pool, work);[m
 [m
[32m+[m	[32mwork->thr_id = thr_id;[m
[32m+[m	[32mwork->work_block = work_block;[m
[32m+[m	[32mwork->pool->works++;[m
[32m+[m
[32m+[m	[32mwork->mined = true;[m
[32m+[m	[32mwork->device_diff = MIN(cgpu->drv->max_diff, work->work_difficulty);[m
[32m+[m
 	submit_nonce(thr, work, nonce);[m
 	free_work(work);[m
 }[m
[1mdiff --git a/driver-avalon2.c b/driver-avalon2.c[m
[1mindex 1a318ab..b7dbcd2 100644[m
[1m--- a/driver-avalon2.c[m
[1m+++ b/driver-avalon2.c[m
[36m@@ -147,12 +147,24 @@[m [mstatic int avalon2_init_pkg(struct avalon2_pkg *pkg, uint8_t type, uint8_t idx,[m
 [m
 static int job_idcmp(uint8_t *job_id, char *pool_job_id)[m
 {[m
[31m-	int i = 0;[m
[31m-	for (i = 0; i < 4; i++) {[m
[31m-		if (job_id[i] != *(pool_job_id + strlen(pool_job_id) - 4 + i))[m
[31m-			return 1;[m
[31m-	}[m
[31m-	return 0;[m
[32m+[m	[32mint job_id_len;[m
[32m+[m	[32munsigned short crc, crc_expect;[m
[32m+[m
[32m+[m	[32mif (!pool_job_id)[m
[32m+[m		[32mreturn 1;[m
[32m+[m
[32m+[m	[32mjob_id_len = strlen(pool_job_id);[m
[32m+[m	[32mcrc_expect = crc16(pool_job_id, job_id_len);[m
[32m+[m
[32m+[m	[32mcrc = job_id[0] << 8 | job_id[1];[m
[32m+[m
[32m+[m	[32mif (crc_expect == crc)[m
[32m+[m		[32mreturn 0;[m
[32m+[m
[32m+[m	[32mapplog(LOG_ERR, "Avalon2: Result job_id not match! [%04x:%04x (%s)]",[m
[32m+[m	[32m       crc, crc_expect, pool_job_id);[m
[32m+[m
[32m+[m	[32mreturn 1;[m
 }[m
 [m
 static inline int get_temp_max(struct avalon2_info *info)[m
[36m@@ -198,7 +210,7 @@[m [mstatic int decode_pkg(struct thr_info *thr, struct avalon2_ret *ar, uint8_t *pkg[m
 	unsigned int actual_crc;[m
 	uint32_t nonce, nonce2, miner, modular_id;[m
 	int pool_no;[m
[31m-	uint8_t job_id[5];[m
[32m+[m	[32muint8_t job_id[4];[m
 	int tmp;[m
 [m
 	int type = AVA2_GETS_ERROR;[m
[36m@@ -232,7 +244,6 @@[m [mstatic int decode_pkg(struct thr_info *thr, struct avalon2_ret *ar, uint8_t *pkg[m
 			memcpy(&nonce2, ar->data + 8, 4);[m
 			/* Calc time    ar->data + 12 */[m
 			memcpy(&nonce, ar->data + 16, 4);[m
[31m-			memset(job_id, 0, 5);[m
 			memcpy(job_id, ar->data + 20, 4);[m
 [m
 			miner = be32toh(miner);[m
[36m@@ -249,15 +260,15 @@[m [mstatic int decode_pkg(struct thr_info *thr, struct avalon2_ret *ar, uint8_t *pkg[m
 			nonce = be32toh(nonce);[m
 			nonce -= 0x180;[m
 [m
[31m-			applog(LOG_DEBUG, "Avalon2: Found! [%s] %d:(%08x) (%08x)",[m
[31m-			       job_id, pool_no, nonce2, nonce);[m
[32m+[m			[32mapplog(LOG_DEBUG, "Avalon2: Found! %d: (%08x) (%08x)",[m
[32m+[m			[32m       pool_no, nonce2, nonce);[m
 			/* FIXME:[m
 			 * We need remember the pre_pool. then submit the stale work */[m
 			pool = pools[pool_no];[m
 			if (job_idcmp(job_id, pool->swork.job_id))[m
 				break;[m
 [m
[31m-			if (thr && !info->new_stratum)[m
[32m+[m			[32mif (thr)[m
 				submit_nonce2_nonce(thr, pool_no, nonce2, nonce);[m
 			break;[m
 		case AVA2_P_STATUS:[m
[36m@@ -278,6 +289,8 @@[m [mstatic int decode_pkg(struct thr_info *thr, struct avalon2_ret *ar, uint8_t *pkg[m
 			memcpy(&(info->power_good[modular_id]), ar->data + 24, 4);[m
 [m
 			info->get_frequency[modular_id] = be32toh(info->get_frequency[modular_id]);[m
[32m+[m			[32mif (info->dev_type[modular_id] == AVA2_ID_AVA3)[m
[32m+[m				[32minfo->get_frequency[modular_id] = info->get_frequency[modular_id] * 768 / 65;[m
 			info->get_voltage[modular_id] = be32toh(info->get_voltage[modular_id]);[m
 			info->local_work[modular_id] = be32toh(info->local_work[modular_id]);[m
 			info->hw_work[modular_id] = be32toh(info->hw_work[modular_id]);[m
[36m@@ -408,6 +421,7 @@[m [mstatic int avalon2_stratum_pkgs(int fd, struct pool *pool, struct thr_info *thr)[m
 	int i, a, b, tmp;[m
 	unsigned char target[32];[m
 	int job_id_len;[m
[32m+[m	[32munsigned short crc;[m
 [m
 	/* Send out the first stratum message STATIC */[m
 	applog(LOG_DEBUG, "Avalon2: Pool stratum message STATIC: %d, %d, %d, %d, %d",[m
[36m@@ -460,10 +474,9 @@[m [mstatic int avalon2_stratum_pkgs(int fd, struct pool *pool, struct thr_info *thr)[m
 	memset(pkg.data, 0, AVA2_P_DATA_LEN);[m
 [m
 	job_id_len = strlen(pool->swork.job_id);[m
[31m-	job_id_len = job_id_len >= 4 ? 4 : job_id_len;[m
[31m-	for (i = 0; i < job_id_len; i++) {[m
[31m-		pkg.data[i] = *(pool->swork.job_id + strlen(pool->swork.job_id) - 4 + i);[m
[31m-	}[m
[32m+[m	[32mcrc = crc16(pool->swork.job_id, job_id_len);[m
[32m+[m	[32mpkg.data[0] = (crc & 0xff00) >> 8;[m
[32m+[m	[32mpkg.data[1] = crc & 0x00ff;[m
 	avalon2_init_pkg(&pkg, AVA2_P_JOB_ID, 1, 1);[m
 	while (avalon2_send_pkg(fd, &pkg, thr) != AVA2_SEND_OK)[m
 		;[m
[36m@@ -576,6 +589,7 @@[m [mstatic bool avalon2_detect_one(const char *devpath)[m
 		memcpy(mm_version[i], ret_pkg.data, 15);[m
 		mm_version[i][15] = '\0';[m
 	}[m
[32m+[m	[32mavalon2_close(fd);[m
 	if (!modular[0] && !modular[1] && !modular[2] && !modular[3])[m
 		return false;[m
 [m
[36m@@ -595,27 +609,23 @@[m [mstatic bool avalon2_detect_one(const char *devpath)[m
 [m
 	info = avalon2->device_data;[m
 [m
[31m-	strcpy(info->mm_version[0], mm_version[0]);[m
[31m-	strcpy(info->mm_version[1], mm_version[1]);[m
[31m-	strcpy(info->mm_version[2], mm_version[2]);[m
[31m-	strcpy(info->mm_version[3], mm_version[3]);[m
[31m-[m
[32m+[m	[32minfo->fd = -1;[m
 	info->baud = AVA2_IO_SPEED;[m
 	info->fan_pwm = AVA2_DEFAULT_FAN_PWM;[m
 	info->set_voltage = AVA2_DEFAULT_VOLTAGE_MIN;[m
 	info->set_frequency = AVA2_DEFAULT_FREQUENCY;[m
 	info->temp_max = 0;[m
[31m-	info->temp_history_index = 0;[m
[31m-	info->temp_sum = 0;[m
[31m-	info->temp_old = 0;[m
[31m-	info->modulars[0] = modular[0];[m
[31m-	info->modulars[1] = modular[1];[m
[31m-	info->modulars[2] = modular[2];	/* Enable modular */[m
[31m-	info->modulars[3] = modular[3];	/* Enable modular */[m
 [m
[31m-	info->fd = -1;[m
[31m-	/* Set asic to idle mode after detect */[m
[31m-	avalon2_close(fd);[m
[32m+[m	[32mfor (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {[m
[32m+[m		[32mstrcpy(info->mm_version[i], mm_version[i]);[m
[32m+[m		[32minfo->modulars[i] = modular[i];	/* Enable modular */[m
[32m+[m		[32minfo->dev_type[i] = AVA2_ID_AVAX;[m
[32m+[m
[32m+[m		[32mif (!strncmp((char *)&(info->mm_version[i]), AVA2_FW2_PREFIXSTR, 2))[m
[32m+[m			[32minfo->dev_type[i] = AVA2_ID_AVA2;[m
[32m+[m		[32mif (!strncmp((char *)&(info->mm_version[i]), AVA2_FW3_PREFIXSTR, 2))[m
[32m+[m			[32minfo->dev_type[i] = AVA2_ID_AVA3;[m
[32m+[m	[32m}[m
 [m
 	return true;[m
 }[m
[36m@@ -654,7 +664,6 @@[m [mstatic bool avalon2_prepare(struct thr_info *thr)[m
 		avalon2_init(avalon2);[m
 [m
 	info->first = true;[m
[31m-[m
 	return true;[m
 }[m
 [m
[36m@@ -696,9 +705,7 @@[m [mstatic int64_t avalon2_scanhash(struct thr_info *thr)[m
 	uint32_t tmp, range, start;[m
 	int i;[m
 [m
[31m-	if (thr->work_restart || thr->work_update ||[m
[31m-	    info->first) {[m
[31m-		info->new_stratum = true;[m
[32m+[m	[32mif (thr->work_restart || thr->work_update || info->first) {[m
 		applog(LOG_DEBUG, "Avalon2: New stratum: restart: %d, update: %d, first: %d",[m
 		       thr->work_restart, thr->work_update, info->first);[m
 		thr->work_update = false;[m
[36m@@ -764,7 +771,6 @@[m [mstatic int64_t avalon2_scanhash(struct thr_info *thr)[m
 		avalon2_init_pkg(&send_pkg, AVA2_P_SET, 1, 1);[m
 		while (avalon2_send_pkg(info->fd, &send_pkg, thr) != AVA2_SEND_OK)[m
 			;[m
[31m-		info->new_stratum = false;[m
 	}[m
 [m
 	polling(thr);[m
[36m@@ -783,18 +789,11 @@[m [mstatic struct api_data *avalon2_api_stats(struct cgpu_info *cgpu)[m
 	int i, j, a, b;[m
 	char buf[24];[m
 	double hwp;[m
[31m-	int devtype[AVA2_DEFAULT_MODULARS];[m
 	int minerindex, minercount;[m
 [m
 	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {[m
[31m-		devtype[i] = AVA2_ID_AVAX;[m
[31m-		if (!strncmp((char *)&(info->mm_version[i]), AVA2_MM_VERNULL, 4))[m
[32m+[m		[32mif(info->dev_type[i] == AVA2_ID_AVAX)[m
 			continue;[m
[31m-		if (!strncmp((char *)&(info->mm_version[i]), AVA2_FW2_PREFIXSTR, 2))[m
[31m-			devtype[i] = AVA2_ID_AVA2;[m
[31m-		if (!strncmp((char *)&(info->mm_version[i]), AVA2_FW3_PREFIXSTR, 2))[m
[31m-			devtype[i] = AVA2_ID_AVA3;[m
[31m-[m
 		sprintf(buf, "ID%d MM Version", i + 1);[m
 		root = api_add_string(root, buf, &(info->mm_version[i]), false);[m
 	}[m
[36m@@ -802,15 +801,15 @@[m [mstatic struct api_data *avalon2_api_stats(struct cgpu_info *cgpu)[m
 	minerindex = 0;[m
 	minercount = 0;[m
 	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {[m
[31m-		if (devtype[i] == AVA2_ID_AVAX) {[m
[32m+[m		[32mif (info->dev_type[i] == AVA2_ID_AVAX) {[m
 			minerindex += AVA2_DEFAULT_MINERS;[m
 			continue;[m
 		}[m
 [m
[31m-		if (devtype[i] == AVA2_ID_AVA2)[m
[32m+[m		[32mif (info->dev_type[i] == AVA2_ID_AVA2)[m
 			minercount = AVA2_DEFAULT_MINERS;[m
 [m
[31m-		if (devtype[i] == AVA2_ID_AVA3)[m
[32m+[m		[32mif (info->dev_type[i] == AVA2_ID_AVA3)[m
 			minercount = AVA2_AVA3_MINERS;[m
 [m
 		for (j = minerindex; j < (minerindex + minercount); j++) {[m
[36m@@ -821,19 +820,19 @@[m [mstatic struct api_data *avalon2_api_stats(struct cgpu_info *cgpu)[m
 	}[m
 [m
 	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {[m
[31m-		if(devtype[i] == AVA2_ID_AVAX)[m
[32m+[m		[32mif(info->dev_type[i] == AVA2_ID_AVAX)[m
 			continue;[m
 		sprintf(buf, "Local works%d", i + 1);[m
 		root = api_add_int(root, buf, &(info->local_works[i]), false);[m
 	}[m
 	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {[m
[31m-		if(devtype[i] == AVA2_ID_AVAX)[m
[32m+[m		[32mif(info->dev_type[i] == AVA2_ID_AVAX)[m
 			continue;[m
 		sprintf(buf, "Hardware error works%d", i + 1);[m
 		root = api_add_int(root, buf, &(info->hw_works[i]), false);[m
 	}[m
 	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {[m
[31m-		if(devtype[i] == AVA2_ID_AVAX)[m
[32m+[m		[32mif(info->dev_type[i] == AVA2_ID_AVAX)[m
 			continue;[m
 		a = info->hw_works[i];[m
 		b = info->local_works[i];[m
[36m@@ -843,31 +842,31 @@[m [mstatic struct api_data *avalon2_api_stats(struct cgpu_info *cgpu)[m
 		root = api_add_percent(root, buf, &hwp, true);[m
 	}[m
 	for (i = 0; i < 2 * AVA2_DEFAULT_MODULARS; i++) {[m
[31m-		if(devtype[i/2] == AVA2_ID_AVAX)[m
[32m+[m		[32mif(info->dev_type[i/2] == AVA2_ID_AVAX)[m
 			continue;[m
 		sprintf(buf, "Temperature%d", i + 1);[m
 		root = api_add_int(root, buf, &(info->temp[i]), false);[m
 	}[m
 	for (i = 0; i < 2 * AVA2_DEFAULT_MODULARS; i++) {[m
[31m-		if(devtype[i/2] == AVA2_ID_AVAX)[m
[32m+[m		[32mif(info->dev_type[i/2] == AVA2_ID_AVAX)[m
 			continue;[m
 		sprintf(buf, "Fan%d", i + 1);[m
 		root = api_add_int(root, buf, &(info->fan[i]), false);[m
 	}[m
 	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {[m
[31m-		if(devtype[i] == AVA2_ID_AVAX)[m
[32m+[m		[32mif(info->dev_type[i] == AVA2_ID_AVAX)[m
 			continue;[m
 		sprintf(buf, "Voltage%d", i + 1);[m
 		root = api_add_int(root, buf, &(info->get_voltage[i]), false);[m
 	}[m
 	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {[m
[31m-		if(devtype[i] == AVA2_ID_AVAX)[m
[32m+[m		[32mif(info->dev_type[i] == AVA2_ID_AVAX)[m
 			continue;[m
 		sprintf(buf, "Frequency%d", i + 1);[m
 		root = api_add_int(root, buf, &(info->get_frequency[i]), false);[m
 	}[m
 	for (i = 0; i < AVA2_DEFAULT_MODULARS; i++) {[m
[31m-		if(devtype[i] == AVA2_ID_AVAX)[m
[32m+[m		[32mif(info->dev_type[i] == AVA2_ID_AVAX)[m
 			continue;[m
 		sprintf(buf, "Power good %02x", i + 1);[m
 		root = api_add_int(root, buf, &(info->power_good[i]), false);[m
[1mdiff --git a/driver-avalon2.h b/driver-avalon2.h[m
[1mindex ee1fb61..d847134 100644[m
[1m--- a/driver-avalon2.h[m
[1m+++ b/driver-avalon2.h[m
[36m@@ -21,8 +21,6 @@[m
 #define AVA2_RESET_FAULT_DECISECONDS	10[m
 #define AVA2_IO_SPEED		115200[m
 [m
[31m-#define AVA2_DEFAULT_MINERS	10[m
[31m-#define AVA2_AVA3_MINERS	5[m
 #define AVA2_DEFAULT_MODULARS	4[m
 [m
 #define AVA2_PWM_MAX	0x3FF[m
[36m@@ -30,15 +28,23 @@[m
 #define AVA2_DEFAULT_FAN_MIN	0[m
 #define AVA2_DEFAULT_FAN_MAX	100[m
 [m
[31m-#define AVA2_DEFAULT_VOLTAGE	10000 /* V * 10000 */[m
[32m+[m[32m#define AVALON2_TEMP_OVERHEAT	88[m
[32m+[m
 #define AVA2_DEFAULT_VOLTAGE_MIN	6000[m
 #define AVA2_DEFAULT_VOLTAGE_MAX	11000[m
 [m
[31m-#define AVA2_DEFAULT_FREQUENCY	1500 /* In MH/s */[m
 #define AVA2_DEFAULT_FREQUENCY_MIN	300[m
 #define AVA2_DEFAULT_FREQUENCY_MAX	2000[m
 [m
[31m-#define AVALON2_TEMP_OVERHEAT	88[m
[32m+[m[32m/* Avalon2 default values */[m
[32m+[m[32m#define AVA2_DEFAULT_MINERS	10[m
[32m+[m[32m#define AVA2_DEFAULT_VOLTAGE	10000 /* v * 10000 */[m
[32m+[m[32m#define AVA2_DEFAULT_FREQUENCY	1500 /* In MHs */[m
[32m+[m
[32m+[m[32m/* Avalon3 default values */[m
[32m+[m[32m#define AVA2_AVA3_MINERS	5[m
[32m+[m[32m#define AVA2_AVA3_VOLTAGE	6625 /* 0.6625v */[m
[32m+[m[32m#define AVA2_AVA3_FREQUENCY	400  /* MHz * 11.8 = MHs: 400MHz means ~4.7GHs */[m
 [m
 /* Avalon2 protocol package type */[m
 #define AVA2_H1	'A'[m
[36m@@ -91,6 +97,7 @@[m [mstruct avalon2_pkg {[m
 #define avalon2_ret avalon2_pkg[m
 [m
 struct avalon2_info {[m
[32m+[m	[32mbool first;[m
 	int fd;[m
 	int baud;[m
 [m
[36m@@ -105,15 +112,7 @@[m [mstruct avalon2_info {[m
 [m
 	int fan[2 * AVA2_DEFAULT_MODULARS];[m
 	int temp[2 * AVA2_DEFAULT_MODULARS];[m
[31m-[m
 	int temp_max;[m
[31m-	int temp_history_count;[m
[31m-	int temp_history_index;[m
[31m-	int temp_sum;[m
[31m-	int temp_old;[m
[31m-[m
[31m-	bool first;[m
[31m-	bool new_stratum;[m
 [m
 	int pool_no;[m
 	int diff;[m
[36m@@ -126,6 +125,7 @@[m [mstruct avalon2_info {[m
 [m
 	int modulars[AVA2_DEFAULT_MODULARS];[m
 	char mm_version[AVA2_DEFAULT_MODULARS][16];[m
[32m+[m	[32mint dev_type[AVA2_DEFAULT_MODULARS];[m
 };[m
 [m
 #define AVA2_WRITE_SIZE (sizeof(struct avalon2_pkg))[m
[1mdiff --git a/util.c b/util.c[m
[1mindex 0317adc..c389574 100644[m
[1m--- a/util.c[m
[1m+++ b/util.c[m
[36m@@ -1685,6 +1685,26 @@[m [mstatic bool parse_notify(struct pool *pool, json_t *val)[m
 	ntime = __json_array_string(val, 7);[m
 	clean = json_is_true(json_array_get(val, 8));[m
 [m
[32m+[m[32m#ifdef USE_AVALON2[m
[32m+[m	[32mstatic struct timeval tv_last, tv_now;[m
[32m+[m
[32m+[m	[32mcgtime(&tv_now);[m
[32m+[m	[32mapplog(LOG_DEBUG, "Stratum: Clean %d: (Now: %ld, Last: %ld) tdiff: %ld",[m
[32m+[m	[32m       clean,[m
[32m+[m	[32m       (long)tv_now.tv_sec, (long)tv_last.tv_sec,[m
[32m+[m	[32m       (long)tdiff(&tv_now, &tv_last));[m
[32m+[m
[32m+[m	[32mif (pool == current_pool() && clean == false) {[m
[32m+[m		[32mif ((long)tdiff(&tv_now, &tv_last) < (long)30) {[m
[32m+[m			[32mapplog(LOG_ERR, "Ignore job_id: %s", job_id);[m
[32m+[m			[32mret = true;[m
[32m+[m			[32mgoto out;[m
[32m+[m		[32m}[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mtv_last.tv_sec = tv_now.tv_sec;[m
[32m+[m	[32mtv_last.tv_usec = tv_now.tv_usec;[m
[32m+[m[32m#endif[m
 	if (!job_id || !prev_hash || !coinbase1 || !coinbase2 || !bbversion || !nbit || !ntime) {[m
 		/* Annoying but we must not leak memory */[m
 		if (job_id)[m
